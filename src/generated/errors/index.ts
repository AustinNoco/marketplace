/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number }
type MaybeErrorWithCode = ErrorWithCode | null | undefined

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map()
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map()

/**
 * ArithmeticError: 'arithmetic error'
 *
 * @category Errors
 * @category generated
 */
export class ArithmeticErrorError extends Error {
  readonly code: number = 0x1770
  readonly name: string = 'ArithmeticError'
  constructor() {
    super('arithmetic error')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ArithmeticErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new ArithmeticErrorError())
createErrorFromNameLookup.set(
  'ArithmeticError',
  () => new ArithmeticErrorError()
)

/**
 * ExpiryTooLarge: 'expiry too large'
 *
 * @category Errors
 * @category generated
 */
export class ExpiryTooLargeError extends Error {
  readonly code: number = 0x1771
  readonly name: string = 'ExpiryTooLarge'
  constructor() {
    super('expiry too large')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ExpiryTooLargeError)
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new ExpiryTooLargeError())
createErrorFromNameLookup.set('ExpiryTooLarge', () => new ExpiryTooLargeError())

/**
 * BadOwner: 'bad owner'
 *
 * @category Errors
 * @category generated
 */
export class BadOwnerError extends Error {
  readonly code: number = 0x1772
  readonly name: string = 'BadOwner'
  constructor() {
    super('bad owner')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BadOwnerError)
    }
  }
}

createErrorFromCodeLookup.set(0x1772, () => new BadOwnerError())
createErrorFromNameLookup.set('BadOwner', () => new BadOwnerError())

/**
 * BadListState: 'bad list state'
 *
 * @category Errors
 * @category generated
 */
export class BadListStateError extends Error {
  readonly code: number = 0x1773
  readonly name: string = 'BadListState'
  constructor() {
    super('bad list state')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BadListStateError)
    }
  }
}

createErrorFromCodeLookup.set(0x1773, () => new BadListStateError())
createErrorFromNameLookup.set('BadListState', () => new BadListStateError())

/**
 * BadRoyaltiesPct: 'royalties pct must be between 0 and 99'
 *
 * @category Errors
 * @category generated
 */
export class BadRoyaltiesPctError extends Error {
  readonly code: number = 0x1774
  readonly name: string = 'BadRoyaltiesPct'
  constructor() {
    super('royalties pct must be between 0 and 99')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BadRoyaltiesPctError)
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new BadRoyaltiesPctError())
createErrorFromNameLookup.set(
  'BadRoyaltiesPct',
  () => new BadRoyaltiesPctError()
)

/**
 * PriceMismatch: 'price mismatch'
 *
 * @category Errors
 * @category generated
 */
export class PriceMismatchError extends Error {
  readonly code: number = 0x1775
  readonly name: string = 'PriceMismatch'
  constructor() {
    super('price mismatch')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PriceMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1775, () => new PriceMismatchError())
createErrorFromNameLookup.set('PriceMismatch', () => new PriceMismatchError())

/**
 * CreatorMismatch: 'creator mismatch'
 *
 * @category Errors
 * @category generated
 */
export class CreatorMismatchError extends Error {
  readonly code: number = 0x1776
  readonly name: string = 'CreatorMismatch'
  constructor() {
    super('creator mismatch')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CreatorMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(0x1776, () => new CreatorMismatchError())
createErrorFromNameLookup.set(
  'CreatorMismatch',
  () => new CreatorMismatchError()
)

/**
 * InsufficientBalance: 'insufficient balance'
 *
 * @category Errors
 * @category generated
 */
export class InsufficientBalanceError extends Error {
  readonly code: number = 0x1777
  readonly name: string = 'InsufficientBalance'
  constructor() {
    super('insufficient balance')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InsufficientBalanceError)
    }
  }
}

createErrorFromCodeLookup.set(0x1777, () => new InsufficientBalanceError())
createErrorFromNameLookup.set(
  'InsufficientBalance',
  () => new InsufficientBalanceError()
)

/**
 * FailedLeafVerification: 'failed leaf verification'
 *
 * @category Errors
 * @category generated
 */
export class FailedLeafVerificationError extends Error {
  readonly code: number = 0x1778
  readonly name: string = 'FailedLeafVerification'
  constructor() {
    super('failed leaf verification')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, FailedLeafVerificationError)
    }
  }
}

createErrorFromCodeLookup.set(0x1778, () => new FailedLeafVerificationError())
createErrorFromNameLookup.set(
  'FailedLeafVerification',
  () => new FailedLeafVerificationError()
)

/**
 * OfferExpired: 'offer has expired'
 *
 * @category Errors
 * @category generated
 */
export class OfferExpiredError extends Error {
  readonly code: number = 0x1779
  readonly name: string = 'OfferExpired'
  constructor() {
    super('offer has expired')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OfferExpiredError)
    }
  }
}

createErrorFromCodeLookup.set(0x1779, () => new OfferExpiredError())
createErrorFromNameLookup.set('OfferExpired', () => new OfferExpiredError())

/**
 * TakerNotAllowed: 'taker not allowed'
 *
 * @category Errors
 * @category generated
 */
export class TakerNotAllowedError extends Error {
  readonly code: number = 0x177a
  readonly name: string = 'TakerNotAllowed'
  constructor() {
    super('taker not allowed')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TakerNotAllowedError)
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new TakerNotAllowedError())
createErrorFromNameLookup.set(
  'TakerNotAllowed',
  () => new TakerNotAllowedError()
)

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code)
  return createError != null ? createError() : null
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name)
  return createError != null ? createError() : null
}
