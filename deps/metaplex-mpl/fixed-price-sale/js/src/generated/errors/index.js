"use strict";
/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorFromName = exports.errorFromCode = exports.WrongGatingTokenError = exports.WrongCollectionMintKeyError = exports.CollectionMintMissingError = exports.WrongGatingDateError = exports.WrongOwnerInTokenGatingAccError = exports.WrongGatingMetadataAccountError = exports.InvalidOwnerForGatingTokenError = exports.GatingTokenMissingError = exports.PrimaryMetadataCreatorsNotProvidedError = exports.MarketOwnerDoesntHaveSharesError = exports.CreatorsIsEmptyError = exports.CreatorsIsGtThanAvailableError = exports.PrimarySaleIsNotAllowedError = exports.MetadataShouldBeMutableError = exports.UserWalletMustMatchUserTokenAccountError = exports.MetadataCreatorsIsEmptyError = exports.SellingResourceAlreadyTakenError = exports.TreasuryIsNotEmptyError = exports.InvalidFunderDestinationError = exports.PayoutTicketExistsError = exports.FunderIsInvalidError = exports.PriceIsZeroError = exports.MarketInInvalidStateError = exports.MarketIsImmutableError = exports.MarketIsSuspendedError = exports.MarketDurationIsNotUnlimitedError = exports.SupplyIsGtThanMaxSupplyError = exports.MathOverflowError = exports.UserReachBuyLimitError = exports.MarketIsEndedError = exports.MarketIsNotStartedError = exports.IncorrectOwnerError = exports.EndDateIsEarlierThanBeginDateError = exports.StartDateIsInPastError = exports.PiecesInOneWalletIsTooMuchError = exports.PublicKeyMismatchError = exports.SellingResourceOwnerInvalidError = exports.DerivedKeyInvalidError = exports.SupplyIsNotProvidedError = exports.SupplyIsGtThanAvailableError = exports.DescriptionIsTooLongError = exports.NameIsTooLongError = exports.StringIsTooLongError = exports.NoValidSignerPresentError = void 0;
const createErrorFromCodeLookup = new Map();
const createErrorFromNameLookup = new Map();
/**
 * NoValidSignerPresent: 'No valid signer present'
 *
 * @category Errors
 * @category generated
 */
class NoValidSignerPresentError extends Error {
    constructor() {
        super('No valid signer present');
        this.code = 0x1770;
        this.name = 'NoValidSignerPresent';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NoValidSignerPresentError);
        }
    }
}
exports.NoValidSignerPresentError = NoValidSignerPresentError;
createErrorFromCodeLookup.set(0x1770, () => new NoValidSignerPresentError());
createErrorFromNameLookup.set('NoValidSignerPresent', () => new NoValidSignerPresentError());
/**
 * StringIsTooLong: 'Some string variable is longer than allowed'
 *
 * @category Errors
 * @category generated
 */
class StringIsTooLongError extends Error {
    constructor() {
        super('Some string variable is longer than allowed');
        this.code = 0x1771;
        this.name = 'StringIsTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, StringIsTooLongError);
        }
    }
}
exports.StringIsTooLongError = StringIsTooLongError;
createErrorFromCodeLookup.set(0x1771, () => new StringIsTooLongError());
createErrorFromNameLookup.set('StringIsTooLong', () => new StringIsTooLongError());
/**
 * NameIsTooLong: 'Name string variable is longer than allowed'
 *
 * @category Errors
 * @category generated
 */
class NameIsTooLongError extends Error {
    constructor() {
        super('Name string variable is longer than allowed');
        this.code = 0x1772;
        this.name = 'NameIsTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NameIsTooLongError);
        }
    }
}
exports.NameIsTooLongError = NameIsTooLongError;
createErrorFromCodeLookup.set(0x1772, () => new NameIsTooLongError());
createErrorFromNameLookup.set('NameIsTooLong', () => new NameIsTooLongError());
/**
 * DescriptionIsTooLong: 'Description string variable is longer than allowed'
 *
 * @category Errors
 * @category generated
 */
class DescriptionIsTooLongError extends Error {
    constructor() {
        super('Description string variable is longer than allowed');
        this.code = 0x1773;
        this.name = 'DescriptionIsTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DescriptionIsTooLongError);
        }
    }
}
exports.DescriptionIsTooLongError = DescriptionIsTooLongError;
createErrorFromCodeLookup.set(0x1773, () => new DescriptionIsTooLongError());
createErrorFromNameLookup.set('DescriptionIsTooLong', () => new DescriptionIsTooLongError());
/**
 * SupplyIsGtThanAvailable: 'Provided supply is gt than available'
 *
 * @category Errors
 * @category generated
 */
class SupplyIsGtThanAvailableError extends Error {
    constructor() {
        super('Provided supply is gt than available');
        this.code = 0x1774;
        this.name = 'SupplyIsGtThanAvailable';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SupplyIsGtThanAvailableError);
        }
    }
}
exports.SupplyIsGtThanAvailableError = SupplyIsGtThanAvailableError;
createErrorFromCodeLookup.set(0x1774, () => new SupplyIsGtThanAvailableError());
createErrorFromNameLookup.set('SupplyIsGtThanAvailable', () => new SupplyIsGtThanAvailableError());
/**
 * SupplyIsNotProvided: 'Supply is not provided'
 *
 * @category Errors
 * @category generated
 */
class SupplyIsNotProvidedError extends Error {
    constructor() {
        super('Supply is not provided');
        this.code = 0x1775;
        this.name = 'SupplyIsNotProvided';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SupplyIsNotProvidedError);
        }
    }
}
exports.SupplyIsNotProvidedError = SupplyIsNotProvidedError;
createErrorFromCodeLookup.set(0x1775, () => new SupplyIsNotProvidedError());
createErrorFromNameLookup.set('SupplyIsNotProvided', () => new SupplyIsNotProvidedError());
/**
 * DerivedKeyInvalid: 'Derived key invalid'
 *
 * @category Errors
 * @category generated
 */
class DerivedKeyInvalidError extends Error {
    constructor() {
        super('Derived key invalid');
        this.code = 0x1776;
        this.name = 'DerivedKeyInvalid';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DerivedKeyInvalidError);
        }
    }
}
exports.DerivedKeyInvalidError = DerivedKeyInvalidError;
createErrorFromCodeLookup.set(0x1776, () => new DerivedKeyInvalidError());
createErrorFromNameLookup.set('DerivedKeyInvalid', () => new DerivedKeyInvalidError());
/**
 * SellingResourceOwnerInvalid: 'Invalid selling resource owner provided'
 *
 * @category Errors
 * @category generated
 */
class SellingResourceOwnerInvalidError extends Error {
    constructor() {
        super('Invalid selling resource owner provided');
        this.code = 0x1777;
        this.name = 'SellingResourceOwnerInvalid';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SellingResourceOwnerInvalidError);
        }
    }
}
exports.SellingResourceOwnerInvalidError = SellingResourceOwnerInvalidError;
createErrorFromCodeLookup.set(0x1777, () => new SellingResourceOwnerInvalidError());
createErrorFromNameLookup.set('SellingResourceOwnerInvalid', () => new SellingResourceOwnerInvalidError());
/**
 * PublicKeyMismatch: 'PublicKeyMismatch'
 *
 * @category Errors
 * @category generated
 */
class PublicKeyMismatchError extends Error {
    constructor() {
        super('PublicKeyMismatch');
        this.code = 0x1778;
        this.name = 'PublicKeyMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PublicKeyMismatchError);
        }
    }
}
exports.PublicKeyMismatchError = PublicKeyMismatchError;
createErrorFromCodeLookup.set(0x1778, () => new PublicKeyMismatchError());
createErrorFromNameLookup.set('PublicKeyMismatch', () => new PublicKeyMismatchError());
/**
 * PiecesInOneWalletIsTooMuch: 'Pieces in one wallet cannot be greater than Max Supply value'
 *
 * @category Errors
 * @category generated
 */
class PiecesInOneWalletIsTooMuchError extends Error {
    constructor() {
        super('Pieces in one wallet cannot be greater than Max Supply value');
        this.code = 0x1779;
        this.name = 'PiecesInOneWalletIsTooMuch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PiecesInOneWalletIsTooMuchError);
        }
    }
}
exports.PiecesInOneWalletIsTooMuchError = PiecesInOneWalletIsTooMuchError;
createErrorFromCodeLookup.set(0x1779, () => new PiecesInOneWalletIsTooMuchError());
createErrorFromNameLookup.set('PiecesInOneWalletIsTooMuch', () => new PiecesInOneWalletIsTooMuchError());
/**
 * StartDateIsInPast: 'StartDate cannot be in the past'
 *
 * @category Errors
 * @category generated
 */
class StartDateIsInPastError extends Error {
    constructor() {
        super('StartDate cannot be in the past');
        this.code = 0x177a;
        this.name = 'StartDateIsInPast';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, StartDateIsInPastError);
        }
    }
}
exports.StartDateIsInPastError = StartDateIsInPastError;
createErrorFromCodeLookup.set(0x177a, () => new StartDateIsInPastError());
createErrorFromNameLookup.set('StartDateIsInPast', () => new StartDateIsInPastError());
/**
 * EndDateIsEarlierThanBeginDate: 'EndDate should not be earlier than StartDate'
 *
 * @category Errors
 * @category generated
 */
class EndDateIsEarlierThanBeginDateError extends Error {
    constructor() {
        super('EndDate should not be earlier than StartDate');
        this.code = 0x177b;
        this.name = 'EndDateIsEarlierThanBeginDate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, EndDateIsEarlierThanBeginDateError);
        }
    }
}
exports.EndDateIsEarlierThanBeginDateError = EndDateIsEarlierThanBeginDateError;
createErrorFromCodeLookup.set(0x177b, () => new EndDateIsEarlierThanBeginDateError());
createErrorFromNameLookup.set('EndDateIsEarlierThanBeginDate', () => new EndDateIsEarlierThanBeginDateError());
/**
 * IncorrectOwner: 'Incorrect account owner'
 *
 * @category Errors
 * @category generated
 */
class IncorrectOwnerError extends Error {
    constructor() {
        super('Incorrect account owner');
        this.code = 0x177c;
        this.name = 'IncorrectOwner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, IncorrectOwnerError);
        }
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
createErrorFromCodeLookup.set(0x177c, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());
/**
 * MarketIsNotStarted: 'Market is not started'
 *
 * @category Errors
 * @category generated
 */
class MarketIsNotStartedError extends Error {
    constructor() {
        super('Market is not started');
        this.code = 0x177d;
        this.name = 'MarketIsNotStarted';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MarketIsNotStartedError);
        }
    }
}
exports.MarketIsNotStartedError = MarketIsNotStartedError;
createErrorFromCodeLookup.set(0x177d, () => new MarketIsNotStartedError());
createErrorFromNameLookup.set('MarketIsNotStarted', () => new MarketIsNotStartedError());
/**
 * MarketIsEnded: 'Market is ended'
 *
 * @category Errors
 * @category generated
 */
class MarketIsEndedError extends Error {
    constructor() {
        super('Market is ended');
        this.code = 0x177e;
        this.name = 'MarketIsEnded';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MarketIsEndedError);
        }
    }
}
exports.MarketIsEndedError = MarketIsEndedError;
createErrorFromCodeLookup.set(0x177e, () => new MarketIsEndedError());
createErrorFromNameLookup.set('MarketIsEnded', () => new MarketIsEndedError());
/**
 * UserReachBuyLimit: 'User reach buy limit'
 *
 * @category Errors
 * @category generated
 */
class UserReachBuyLimitError extends Error {
    constructor() {
        super('User reach buy limit');
        this.code = 0x177f;
        this.name = 'UserReachBuyLimit';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UserReachBuyLimitError);
        }
    }
}
exports.UserReachBuyLimitError = UserReachBuyLimitError;
createErrorFromCodeLookup.set(0x177f, () => new UserReachBuyLimitError());
createErrorFromNameLookup.set('UserReachBuyLimit', () => new UserReachBuyLimitError());
/**
 * MathOverflow: 'Math overflow'
 *
 * @category Errors
 * @category generated
 */
class MathOverflowError extends Error {
    constructor() {
        super('Math overflow');
        this.code = 0x1780;
        this.name = 'MathOverflow';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MathOverflowError);
        }
    }
}
exports.MathOverflowError = MathOverflowError;
createErrorFromCodeLookup.set(0x1780, () => new MathOverflowError());
createErrorFromNameLookup.set('MathOverflow', () => new MathOverflowError());
/**
 * SupplyIsGtThanMaxSupply: 'Supply is gt than max supply'
 *
 * @category Errors
 * @category generated
 */
class SupplyIsGtThanMaxSupplyError extends Error {
    constructor() {
        super('Supply is gt than max supply');
        this.code = 0x1781;
        this.name = 'SupplyIsGtThanMaxSupply';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SupplyIsGtThanMaxSupplyError);
        }
    }
}
exports.SupplyIsGtThanMaxSupplyError = SupplyIsGtThanMaxSupplyError;
createErrorFromCodeLookup.set(0x1781, () => new SupplyIsGtThanMaxSupplyError());
createErrorFromNameLookup.set('SupplyIsGtThanMaxSupply', () => new SupplyIsGtThanMaxSupplyError());
/**
 * MarketDurationIsNotUnlimited: 'Market duration is not unlimited'
 *
 * @category Errors
 * @category generated
 */
class MarketDurationIsNotUnlimitedError extends Error {
    constructor() {
        super('Market duration is not unlimited');
        this.code = 0x1782;
        this.name = 'MarketDurationIsNotUnlimited';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MarketDurationIsNotUnlimitedError);
        }
    }
}
exports.MarketDurationIsNotUnlimitedError = MarketDurationIsNotUnlimitedError;
createErrorFromCodeLookup.set(0x1782, () => new MarketDurationIsNotUnlimitedError());
createErrorFromNameLookup.set('MarketDurationIsNotUnlimited', () => new MarketDurationIsNotUnlimitedError());
/**
 * MarketIsSuspended: 'Market is suspended'
 *
 * @category Errors
 * @category generated
 */
class MarketIsSuspendedError extends Error {
    constructor() {
        super('Market is suspended');
        this.code = 0x1783;
        this.name = 'MarketIsSuspended';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MarketIsSuspendedError);
        }
    }
}
exports.MarketIsSuspendedError = MarketIsSuspendedError;
createErrorFromCodeLookup.set(0x1783, () => new MarketIsSuspendedError());
createErrorFromNameLookup.set('MarketIsSuspended', () => new MarketIsSuspendedError());
/**
 * MarketIsImmutable: 'Market is immutable'
 *
 * @category Errors
 * @category generated
 */
class MarketIsImmutableError extends Error {
    constructor() {
        super('Market is immutable');
        this.code = 0x1784;
        this.name = 'MarketIsImmutable';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MarketIsImmutableError);
        }
    }
}
exports.MarketIsImmutableError = MarketIsImmutableError;
createErrorFromCodeLookup.set(0x1784, () => new MarketIsImmutableError());
createErrorFromNameLookup.set('MarketIsImmutable', () => new MarketIsImmutableError());
/**
 * MarketInInvalidState: 'Market in invalid state'
 *
 * @category Errors
 * @category generated
 */
class MarketInInvalidStateError extends Error {
    constructor() {
        super('Market in invalid state');
        this.code = 0x1785;
        this.name = 'MarketInInvalidState';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MarketInInvalidStateError);
        }
    }
}
exports.MarketInInvalidStateError = MarketInInvalidStateError;
createErrorFromCodeLookup.set(0x1785, () => new MarketInInvalidStateError());
createErrorFromNameLookup.set('MarketInInvalidState', () => new MarketInInvalidStateError());
/**
 * PriceIsZero: 'Price is zero'
 *
 * @category Errors
 * @category generated
 */
class PriceIsZeroError extends Error {
    constructor() {
        super('Price is zero');
        this.code = 0x1786;
        this.name = 'PriceIsZero';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PriceIsZeroError);
        }
    }
}
exports.PriceIsZeroError = PriceIsZeroError;
createErrorFromCodeLookup.set(0x1786, () => new PriceIsZeroError());
createErrorFromNameLookup.set('PriceIsZero', () => new PriceIsZeroError());
/**
 * FunderIsInvalid: 'Funder is invalid'
 *
 * @category Errors
 * @category generated
 */
class FunderIsInvalidError extends Error {
    constructor() {
        super('Funder is invalid');
        this.code = 0x1787;
        this.name = 'FunderIsInvalid';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, FunderIsInvalidError);
        }
    }
}
exports.FunderIsInvalidError = FunderIsInvalidError;
createErrorFromCodeLookup.set(0x1787, () => new FunderIsInvalidError());
createErrorFromNameLookup.set('FunderIsInvalid', () => new FunderIsInvalidError());
/**
 * PayoutTicketExists: 'Payout ticket exists'
 *
 * @category Errors
 * @category generated
 */
class PayoutTicketExistsError extends Error {
    constructor() {
        super('Payout ticket exists');
        this.code = 0x1788;
        this.name = 'PayoutTicketExists';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PayoutTicketExistsError);
        }
    }
}
exports.PayoutTicketExistsError = PayoutTicketExistsError;
createErrorFromCodeLookup.set(0x1788, () => new PayoutTicketExistsError());
createErrorFromNameLookup.set('PayoutTicketExists', () => new PayoutTicketExistsError());
/**
 * InvalidFunderDestination: 'Funder provide invalid destination'
 *
 * @category Errors
 * @category generated
 */
class InvalidFunderDestinationError extends Error {
    constructor() {
        super('Funder provide invalid destination');
        this.code = 0x1789;
        this.name = 'InvalidFunderDestination';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidFunderDestinationError);
        }
    }
}
exports.InvalidFunderDestinationError = InvalidFunderDestinationError;
createErrorFromCodeLookup.set(0x1789, () => new InvalidFunderDestinationError());
createErrorFromNameLookup.set('InvalidFunderDestination', () => new InvalidFunderDestinationError());
/**
 * TreasuryIsNotEmpty: 'Treasury is not empty'
 *
 * @category Errors
 * @category generated
 */
class TreasuryIsNotEmptyError extends Error {
    constructor() {
        super('Treasury is not empty');
        this.code = 0x178a;
        this.name = 'TreasuryIsNotEmpty';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TreasuryIsNotEmptyError);
        }
    }
}
exports.TreasuryIsNotEmptyError = TreasuryIsNotEmptyError;
createErrorFromCodeLookup.set(0x178a, () => new TreasuryIsNotEmptyError());
createErrorFromNameLookup.set('TreasuryIsNotEmpty', () => new TreasuryIsNotEmptyError());
/**
 * SellingResourceAlreadyTaken: 'Selling resource already taken by other market'
 *
 * @category Errors
 * @category generated
 */
class SellingResourceAlreadyTakenError extends Error {
    constructor() {
        super('Selling resource already taken by other market');
        this.code = 0x178b;
        this.name = 'SellingResourceAlreadyTaken';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SellingResourceAlreadyTakenError);
        }
    }
}
exports.SellingResourceAlreadyTakenError = SellingResourceAlreadyTakenError;
createErrorFromCodeLookup.set(0x178b, () => new SellingResourceAlreadyTakenError());
createErrorFromNameLookup.set('SellingResourceAlreadyTaken', () => new SellingResourceAlreadyTakenError());
/**
 * MetadataCreatorsIsEmpty: 'Metadata creators is empty'
 *
 * @category Errors
 * @category generated
 */
class MetadataCreatorsIsEmptyError extends Error {
    constructor() {
        super('Metadata creators is empty');
        this.code = 0x178c;
        this.name = 'MetadataCreatorsIsEmpty';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MetadataCreatorsIsEmptyError);
        }
    }
}
exports.MetadataCreatorsIsEmptyError = MetadataCreatorsIsEmptyError;
createErrorFromCodeLookup.set(0x178c, () => new MetadataCreatorsIsEmptyError());
createErrorFromNameLookup.set('MetadataCreatorsIsEmpty', () => new MetadataCreatorsIsEmptyError());
/**
 * UserWalletMustMatchUserTokenAccount: 'User wallet must match user token account'
 *
 * @category Errors
 * @category generated
 */
class UserWalletMustMatchUserTokenAccountError extends Error {
    constructor() {
        super('User wallet must match user token account');
        this.code = 0x178d;
        this.name = 'UserWalletMustMatchUserTokenAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UserWalletMustMatchUserTokenAccountError);
        }
    }
}
exports.UserWalletMustMatchUserTokenAccountError = UserWalletMustMatchUserTokenAccountError;
createErrorFromCodeLookup.set(0x178d, () => new UserWalletMustMatchUserTokenAccountError());
createErrorFromNameLookup.set('UserWalletMustMatchUserTokenAccount', () => new UserWalletMustMatchUserTokenAccountError());
/**
 * MetadataShouldBeMutable: 'Metadata should be mutable'
 *
 * @category Errors
 * @category generated
 */
class MetadataShouldBeMutableError extends Error {
    constructor() {
        super('Metadata should be mutable');
        this.code = 0x178e;
        this.name = 'MetadataShouldBeMutable';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MetadataShouldBeMutableError);
        }
    }
}
exports.MetadataShouldBeMutableError = MetadataShouldBeMutableError;
createErrorFromCodeLookup.set(0x178e, () => new MetadataShouldBeMutableError());
createErrorFromNameLookup.set('MetadataShouldBeMutable', () => new MetadataShouldBeMutableError());
/**
 * PrimarySaleIsNotAllowed: 'Primary sale is not allowed'
 *
 * @category Errors
 * @category generated
 */
class PrimarySaleIsNotAllowedError extends Error {
    constructor() {
        super('Primary sale is not allowed');
        this.code = 0x178f;
        this.name = 'PrimarySaleIsNotAllowed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrimarySaleIsNotAllowedError);
        }
    }
}
exports.PrimarySaleIsNotAllowedError = PrimarySaleIsNotAllowedError;
createErrorFromCodeLookup.set(0x178f, () => new PrimarySaleIsNotAllowedError());
createErrorFromNameLookup.set('PrimarySaleIsNotAllowed', () => new PrimarySaleIsNotAllowedError());
/**
 * CreatorsIsGtThanAvailable: 'Creators is gt than allowed'
 *
 * @category Errors
 * @category generated
 */
class CreatorsIsGtThanAvailableError extends Error {
    constructor() {
        super('Creators is gt than allowed');
        this.code = 0x1790;
        this.name = 'CreatorsIsGtThanAvailable';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorsIsGtThanAvailableError);
        }
    }
}
exports.CreatorsIsGtThanAvailableError = CreatorsIsGtThanAvailableError;
createErrorFromCodeLookup.set(0x1790, () => new CreatorsIsGtThanAvailableError());
createErrorFromNameLookup.set('CreatorsIsGtThanAvailable', () => new CreatorsIsGtThanAvailableError());
/**
 * CreatorsIsEmpty: 'Creators is empty'
 *
 * @category Errors
 * @category generated
 */
class CreatorsIsEmptyError extends Error {
    constructor() {
        super('Creators is empty');
        this.code = 0x1791;
        this.name = 'CreatorsIsEmpty';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorsIsEmptyError);
        }
    }
}
exports.CreatorsIsEmptyError = CreatorsIsEmptyError;
createErrorFromCodeLookup.set(0x1791, () => new CreatorsIsEmptyError());
createErrorFromNameLookup.set('CreatorsIsEmpty', () => new CreatorsIsEmptyError());
/**
 * MarketOwnerDoesntHaveShares: 'Market owner doesn't receive shares at primary sale'
 *
 * @category Errors
 * @category generated
 */
class MarketOwnerDoesntHaveSharesError extends Error {
    constructor() {
        super("Market owner doesn't receive shares at primary sale");
        this.code = 0x1792;
        this.name = 'MarketOwnerDoesntHaveShares';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MarketOwnerDoesntHaveSharesError);
        }
    }
}
exports.MarketOwnerDoesntHaveSharesError = MarketOwnerDoesntHaveSharesError;
createErrorFromCodeLookup.set(0x1792, () => new MarketOwnerDoesntHaveSharesError());
createErrorFromNameLookup.set('MarketOwnerDoesntHaveShares', () => new MarketOwnerDoesntHaveSharesError());
/**
 * PrimaryMetadataCreatorsNotProvided: 'PrimaryMetadataCreatorsNotProvided'
 *
 * @category Errors
 * @category generated
 */
class PrimaryMetadataCreatorsNotProvidedError extends Error {
    constructor() {
        super('PrimaryMetadataCreatorsNotProvided');
        this.code = 0x1793;
        this.name = 'PrimaryMetadataCreatorsNotProvided';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrimaryMetadataCreatorsNotProvidedError);
        }
    }
}
exports.PrimaryMetadataCreatorsNotProvidedError = PrimaryMetadataCreatorsNotProvidedError;
createErrorFromCodeLookup.set(0x1793, () => new PrimaryMetadataCreatorsNotProvidedError());
createErrorFromNameLookup.set('PrimaryMetadataCreatorsNotProvided', () => new PrimaryMetadataCreatorsNotProvidedError());
/**
 * GatingTokenMissing: 'Gating token is missing'
 *
 * @category Errors
 * @category generated
 */
class GatingTokenMissingError extends Error {
    constructor() {
        super('Gating token is missing');
        this.code = 0x1794;
        this.name = 'GatingTokenMissing';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, GatingTokenMissingError);
        }
    }
}
exports.GatingTokenMissingError = GatingTokenMissingError;
createErrorFromCodeLookup.set(0x1794, () => new GatingTokenMissingError());
createErrorFromNameLookup.set('GatingTokenMissing', () => new GatingTokenMissingError());
/**
 * InvalidOwnerForGatingToken: 'Invalid program owner for the gating token account'
 *
 * @category Errors
 * @category generated
 */
class InvalidOwnerForGatingTokenError extends Error {
    constructor() {
        super('Invalid program owner for the gating token account');
        this.code = 0x1795;
        this.name = 'InvalidOwnerForGatingToken';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidOwnerForGatingTokenError);
        }
    }
}
exports.InvalidOwnerForGatingTokenError = InvalidOwnerForGatingTokenError;
createErrorFromCodeLookup.set(0x1795, () => new InvalidOwnerForGatingTokenError());
createErrorFromNameLookup.set('InvalidOwnerForGatingToken', () => new InvalidOwnerForGatingTokenError());
/**
 * WrongGatingMetadataAccount: 'Wrong Metadata account for the gating token'
 *
 * @category Errors
 * @category generated
 */
class WrongGatingMetadataAccountError extends Error {
    constructor() {
        super('Wrong Metadata account for the gating token');
        this.code = 0x1796;
        this.name = 'WrongGatingMetadataAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, WrongGatingMetadataAccountError);
        }
    }
}
exports.WrongGatingMetadataAccountError = WrongGatingMetadataAccountError;
createErrorFromCodeLookup.set(0x1796, () => new WrongGatingMetadataAccountError());
createErrorFromNameLookup.set('WrongGatingMetadataAccount', () => new WrongGatingMetadataAccountError());
/**
 * WrongOwnerInTokenGatingAcc: 'Wrong owner in token gating account'
 *
 * @category Errors
 * @category generated
 */
class WrongOwnerInTokenGatingAccError extends Error {
    constructor() {
        super('Wrong owner in token gating account');
        this.code = 0x1797;
        this.name = 'WrongOwnerInTokenGatingAcc';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, WrongOwnerInTokenGatingAccError);
        }
    }
}
exports.WrongOwnerInTokenGatingAccError = WrongOwnerInTokenGatingAccError;
createErrorFromCodeLookup.set(0x1797, () => new WrongOwnerInTokenGatingAccError());
createErrorFromNameLookup.set('WrongOwnerInTokenGatingAcc', () => new WrongOwnerInTokenGatingAccError());
/**
 * WrongGatingDate: 'Wrong gating date send'
 *
 * @category Errors
 * @category generated
 */
class WrongGatingDateError extends Error {
    constructor() {
        super('Wrong gating date send');
        this.code = 0x1798;
        this.name = 'WrongGatingDate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, WrongGatingDateError);
        }
    }
}
exports.WrongGatingDateError = WrongGatingDateError;
createErrorFromCodeLookup.set(0x1798, () => new WrongGatingDateError());
createErrorFromNameLookup.set('WrongGatingDate', () => new WrongGatingDateError());
/**
 * CollectionMintMissing: 'Collection mint is missing'
 *
 * @category Errors
 * @category generated
 */
class CollectionMintMissingError extends Error {
    constructor() {
        super('Collection mint is missing');
        this.code = 0x1799;
        this.name = 'CollectionMintMissing';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionMintMissingError);
        }
    }
}
exports.CollectionMintMissingError = CollectionMintMissingError;
createErrorFromCodeLookup.set(0x1799, () => new CollectionMintMissingError());
createErrorFromNameLookup.set('CollectionMintMissing', () => new CollectionMintMissingError());
/**
 * WrongCollectionMintKey: 'Wrong collection mint key'
 *
 * @category Errors
 * @category generated
 */
class WrongCollectionMintKeyError extends Error {
    constructor() {
        super('Wrong collection mint key');
        this.code = 0x179a;
        this.name = 'WrongCollectionMintKey';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, WrongCollectionMintKeyError);
        }
    }
}
exports.WrongCollectionMintKeyError = WrongCollectionMintKeyError;
createErrorFromCodeLookup.set(0x179a, () => new WrongCollectionMintKeyError());
createErrorFromNameLookup.set('WrongCollectionMintKey', () => new WrongCollectionMintKeyError());
/**
 * WrongGatingToken: 'Wrong gating token'
 *
 * @category Errors
 * @category generated
 */
class WrongGatingTokenError extends Error {
    constructor() {
        super('Wrong gating token');
        this.code = 0x179b;
        this.name = 'WrongGatingToken';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, WrongGatingTokenError);
        }
    }
}
exports.WrongGatingTokenError = WrongGatingTokenError;
createErrorFromCodeLookup.set(0x179b, () => new WrongGatingTokenError());
createErrorFromNameLookup.set('WrongGatingToken', () => new WrongGatingTokenError());
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
function errorFromCode(code) {
    const createError = createErrorFromCodeLookup.get(code);
    return createError != null ? createError() : null;
}
exports.errorFromCode = errorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
function errorFromName(name) {
    const createError = createErrorFromNameLookup.get(name);
    return createError != null ? createError() : null;
}
exports.errorFromName = errorFromName;
