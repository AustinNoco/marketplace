"use strict";
/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorFromName = exports.errorFromCode = exports.CollectionMustBeSizedError = exports.LeafAuthorityMustSignError = exports.UpdateAuthorityIncorrectError = exports.AlreadyUnverifiedError = exports.AlreadyVerifiedError = exports.CollectionNotFoundError = exports.CollectionCannotBeVerifiedInThisInstructionError = exports.IncorrectOwnerError = exports.NumericalOverflowErrorError = exports.InsufficientMintCapacityError = exports.TreeAuthorityIncorrectError = exports.MetadataBasisPointsTooHighError = exports.MetadataUriTooLongError = exports.MetadataSymbolTooLongError = exports.MetadataNameTooLongError = exports.CreatorsTooLongError = exports.DataHashMismatchError = exports.CreatorHashMismatchError = exports.NoCreatorsPresentError = exports.CreatorNotFoundError = exports.CreatorDidNotVerifyError = exports.DuplicateCreatorAddressError = exports.CreatorShareTotalMustBe100Error = exports.UnsupportedSchemaVersionError = exports.HashingMismatchError = exports.PublicKeyMismatchError = exports.AssetOwnerMismatchError = void 0;
const createErrorFromCodeLookup = new Map();
const createErrorFromNameLookup = new Map();
/**
 * AssetOwnerMismatch: 'Asset Owner Does not match'
 *
 * @category Errors
 * @category generated
 */
class AssetOwnerMismatchError extends Error {
    constructor() {
        super('Asset Owner Does not match');
        this.code = 0x1770;
        this.name = 'AssetOwnerMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AssetOwnerMismatchError);
        }
    }
}
exports.AssetOwnerMismatchError = AssetOwnerMismatchError;
createErrorFromCodeLookup.set(0x1770, () => new AssetOwnerMismatchError());
createErrorFromNameLookup.set('AssetOwnerMismatch', () => new AssetOwnerMismatchError());
/**
 * PublicKeyMismatch: 'PublicKeyMismatch'
 *
 * @category Errors
 * @category generated
 */
class PublicKeyMismatchError extends Error {
    constructor() {
        super('PublicKeyMismatch');
        this.code = 0x1771;
        this.name = 'PublicKeyMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PublicKeyMismatchError);
        }
    }
}
exports.PublicKeyMismatchError = PublicKeyMismatchError;
createErrorFromCodeLookup.set(0x1771, () => new PublicKeyMismatchError());
createErrorFromNameLookup.set('PublicKeyMismatch', () => new PublicKeyMismatchError());
/**
 * HashingMismatch: 'Hashing Mismatch Within Leaf Schema'
 *
 * @category Errors
 * @category generated
 */
class HashingMismatchError extends Error {
    constructor() {
        super('Hashing Mismatch Within Leaf Schema');
        this.code = 0x1772;
        this.name = 'HashingMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, HashingMismatchError);
        }
    }
}
exports.HashingMismatchError = HashingMismatchError;
createErrorFromCodeLookup.set(0x1772, () => new HashingMismatchError());
createErrorFromNameLookup.set('HashingMismatch', () => new HashingMismatchError());
/**
 * UnsupportedSchemaVersion: 'Unsupported Schema Version'
 *
 * @category Errors
 * @category generated
 */
class UnsupportedSchemaVersionError extends Error {
    constructor() {
        super('Unsupported Schema Version');
        this.code = 0x1773;
        this.name = 'UnsupportedSchemaVersion';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UnsupportedSchemaVersionError);
        }
    }
}
exports.UnsupportedSchemaVersionError = UnsupportedSchemaVersionError;
createErrorFromCodeLookup.set(0x1773, () => new UnsupportedSchemaVersionError());
createErrorFromNameLookup.set('UnsupportedSchemaVersion', () => new UnsupportedSchemaVersionError());
/**
 * CreatorShareTotalMustBe100: 'Creator shares must sum to 100'
 *
 * @category Errors
 * @category generated
 */
class CreatorShareTotalMustBe100Error extends Error {
    constructor() {
        super('Creator shares must sum to 100');
        this.code = 0x1774;
        this.name = 'CreatorShareTotalMustBe100';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorShareTotalMustBe100Error);
        }
    }
}
exports.CreatorShareTotalMustBe100Error = CreatorShareTotalMustBe100Error;
createErrorFromCodeLookup.set(0x1774, () => new CreatorShareTotalMustBe100Error());
createErrorFromNameLookup.set('CreatorShareTotalMustBe100', () => new CreatorShareTotalMustBe100Error());
/**
 * DuplicateCreatorAddress: 'No duplicate creator addresses in metadata'
 *
 * @category Errors
 * @category generated
 */
class DuplicateCreatorAddressError extends Error {
    constructor() {
        super('No duplicate creator addresses in metadata');
        this.code = 0x1775;
        this.name = 'DuplicateCreatorAddress';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DuplicateCreatorAddressError);
        }
    }
}
exports.DuplicateCreatorAddressError = DuplicateCreatorAddressError;
createErrorFromCodeLookup.set(0x1775, () => new DuplicateCreatorAddressError());
createErrorFromNameLookup.set('DuplicateCreatorAddress', () => new DuplicateCreatorAddressError());
/**
 * CreatorDidNotVerify: 'Creator did not verify the metadata'
 *
 * @category Errors
 * @category generated
 */
class CreatorDidNotVerifyError extends Error {
    constructor() {
        super('Creator did not verify the metadata');
        this.code = 0x1776;
        this.name = 'CreatorDidNotVerify';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorDidNotVerifyError);
        }
    }
}
exports.CreatorDidNotVerifyError = CreatorDidNotVerifyError;
createErrorFromCodeLookup.set(0x1776, () => new CreatorDidNotVerifyError());
createErrorFromNameLookup.set('CreatorDidNotVerify', () => new CreatorDidNotVerifyError());
/**
 * CreatorNotFound: 'Creator not found in creator Vec'
 *
 * @category Errors
 * @category generated
 */
class CreatorNotFoundError extends Error {
    constructor() {
        super('Creator not found in creator Vec');
        this.code = 0x1777;
        this.name = 'CreatorNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorNotFoundError);
        }
    }
}
exports.CreatorNotFoundError = CreatorNotFoundError;
createErrorFromCodeLookup.set(0x1777, () => new CreatorNotFoundError());
createErrorFromNameLookup.set('CreatorNotFound', () => new CreatorNotFoundError());
/**
 * NoCreatorsPresent: 'No creators in creator Vec'
 *
 * @category Errors
 * @category generated
 */
class NoCreatorsPresentError extends Error {
    constructor() {
        super('No creators in creator Vec');
        this.code = 0x1778;
        this.name = 'NoCreatorsPresent';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NoCreatorsPresentError);
        }
    }
}
exports.NoCreatorsPresentError = NoCreatorsPresentError;
createErrorFromCodeLookup.set(0x1778, () => new NoCreatorsPresentError());
createErrorFromNameLookup.set('NoCreatorsPresent', () => new NoCreatorsPresentError());
/**
 * CreatorHashMismatch: 'User-provided creator Vec must result in same user-provided creator hash'
 *
 * @category Errors
 * @category generated
 */
class CreatorHashMismatchError extends Error {
    constructor() {
        super('User-provided creator Vec must result in same user-provided creator hash');
        this.code = 0x1779;
        this.name = 'CreatorHashMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorHashMismatchError);
        }
    }
}
exports.CreatorHashMismatchError = CreatorHashMismatchError;
createErrorFromCodeLookup.set(0x1779, () => new CreatorHashMismatchError());
createErrorFromNameLookup.set('CreatorHashMismatch', () => new CreatorHashMismatchError());
/**
 * DataHashMismatch: 'User-provided metadata must result in same user-provided data hash'
 *
 * @category Errors
 * @category generated
 */
class DataHashMismatchError extends Error {
    constructor() {
        super('User-provided metadata must result in same user-provided data hash');
        this.code = 0x177a;
        this.name = 'DataHashMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DataHashMismatchError);
        }
    }
}
exports.DataHashMismatchError = DataHashMismatchError;
createErrorFromCodeLookup.set(0x177a, () => new DataHashMismatchError());
createErrorFromNameLookup.set('DataHashMismatch', () => new DataHashMismatchError());
/**
 * CreatorsTooLong: 'Creators list too long'
 *
 * @category Errors
 * @category generated
 */
class CreatorsTooLongError extends Error {
    constructor() {
        super('Creators list too long');
        this.code = 0x177b;
        this.name = 'CreatorsTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorsTooLongError);
        }
    }
}
exports.CreatorsTooLongError = CreatorsTooLongError;
createErrorFromCodeLookup.set(0x177b, () => new CreatorsTooLongError());
createErrorFromNameLookup.set('CreatorsTooLong', () => new CreatorsTooLongError());
/**
 * MetadataNameTooLong: 'Name in metadata is too long'
 *
 * @category Errors
 * @category generated
 */
class MetadataNameTooLongError extends Error {
    constructor() {
        super('Name in metadata is too long');
        this.code = 0x177c;
        this.name = 'MetadataNameTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MetadataNameTooLongError);
        }
    }
}
exports.MetadataNameTooLongError = MetadataNameTooLongError;
createErrorFromCodeLookup.set(0x177c, () => new MetadataNameTooLongError());
createErrorFromNameLookup.set('MetadataNameTooLong', () => new MetadataNameTooLongError());
/**
 * MetadataSymbolTooLong: 'Symbol in metadata is too long'
 *
 * @category Errors
 * @category generated
 */
class MetadataSymbolTooLongError extends Error {
    constructor() {
        super('Symbol in metadata is too long');
        this.code = 0x177d;
        this.name = 'MetadataSymbolTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MetadataSymbolTooLongError);
        }
    }
}
exports.MetadataSymbolTooLongError = MetadataSymbolTooLongError;
createErrorFromCodeLookup.set(0x177d, () => new MetadataSymbolTooLongError());
createErrorFromNameLookup.set('MetadataSymbolTooLong', () => new MetadataSymbolTooLongError());
/**
 * MetadataUriTooLong: 'Uri in metadata is too long'
 *
 * @category Errors
 * @category generated
 */
class MetadataUriTooLongError extends Error {
    constructor() {
        super('Uri in metadata is too long');
        this.code = 0x177e;
        this.name = 'MetadataUriTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MetadataUriTooLongError);
        }
    }
}
exports.MetadataUriTooLongError = MetadataUriTooLongError;
createErrorFromCodeLookup.set(0x177e, () => new MetadataUriTooLongError());
createErrorFromNameLookup.set('MetadataUriTooLong', () => new MetadataUriTooLongError());
/**
 * MetadataBasisPointsTooHigh: 'Basis points in metadata cannot exceed 10000'
 *
 * @category Errors
 * @category generated
 */
class MetadataBasisPointsTooHighError extends Error {
    constructor() {
        super('Basis points in metadata cannot exceed 10000');
        this.code = 0x177f;
        this.name = 'MetadataBasisPointsTooHigh';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MetadataBasisPointsTooHighError);
        }
    }
}
exports.MetadataBasisPointsTooHighError = MetadataBasisPointsTooHighError;
createErrorFromCodeLookup.set(0x177f, () => new MetadataBasisPointsTooHighError());
createErrorFromNameLookup.set('MetadataBasisPointsTooHigh', () => new MetadataBasisPointsTooHighError());
/**
 * TreeAuthorityIncorrect: 'Tree creator or tree delegate must sign.'
 *
 * @category Errors
 * @category generated
 */
class TreeAuthorityIncorrectError extends Error {
    constructor() {
        super('Tree creator or tree delegate must sign.');
        this.code = 0x1780;
        this.name = 'TreeAuthorityIncorrect';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TreeAuthorityIncorrectError);
        }
    }
}
exports.TreeAuthorityIncorrectError = TreeAuthorityIncorrectError;
createErrorFromCodeLookup.set(0x1780, () => new TreeAuthorityIncorrectError());
createErrorFromNameLookup.set('TreeAuthorityIncorrect', () => new TreeAuthorityIncorrectError());
/**
 * InsufficientMintCapacity: 'Not enough unapproved mints left'
 *
 * @category Errors
 * @category generated
 */
class InsufficientMintCapacityError extends Error {
    constructor() {
        super('Not enough unapproved mints left');
        this.code = 0x1781;
        this.name = 'InsufficientMintCapacity';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InsufficientMintCapacityError);
        }
    }
}
exports.InsufficientMintCapacityError = InsufficientMintCapacityError;
createErrorFromCodeLookup.set(0x1781, () => new InsufficientMintCapacityError());
createErrorFromNameLookup.set('InsufficientMintCapacity', () => new InsufficientMintCapacityError());
/**
 * NumericalOverflowError: 'NumericalOverflowError'
 *
 * @category Errors
 * @category generated
 */
class NumericalOverflowErrorError extends Error {
    constructor() {
        super('NumericalOverflowError');
        this.code = 0x1782;
        this.name = 'NumericalOverflowError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NumericalOverflowErrorError);
        }
    }
}
exports.NumericalOverflowErrorError = NumericalOverflowErrorError;
createErrorFromCodeLookup.set(0x1782, () => new NumericalOverflowErrorError());
createErrorFromNameLookup.set('NumericalOverflowError', () => new NumericalOverflowErrorError());
/**
 * IncorrectOwner: 'Incorrect account owner'
 *
 * @category Errors
 * @category generated
 */
class IncorrectOwnerError extends Error {
    constructor() {
        super('Incorrect account owner');
        this.code = 0x1783;
        this.name = 'IncorrectOwner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, IncorrectOwnerError);
        }
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
createErrorFromCodeLookup.set(0x1783, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());
/**
 * CollectionCannotBeVerifiedInThisInstruction: 'Cannot Verify Collection in this Instruction'
 *
 * @category Errors
 * @category generated
 */
class CollectionCannotBeVerifiedInThisInstructionError extends Error {
    constructor() {
        super('Cannot Verify Collection in this Instruction');
        this.code = 0x1784;
        this.name = 'CollectionCannotBeVerifiedInThisInstruction';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionCannotBeVerifiedInThisInstructionError);
        }
    }
}
exports.CollectionCannotBeVerifiedInThisInstructionError = CollectionCannotBeVerifiedInThisInstructionError;
createErrorFromCodeLookup.set(0x1784, () => new CollectionCannotBeVerifiedInThisInstructionError());
createErrorFromNameLookup.set('CollectionCannotBeVerifiedInThisInstruction', () => new CollectionCannotBeVerifiedInThisInstructionError());
/**
 * CollectionNotFound: 'Collection Not Found on Metadata'
 *
 * @category Errors
 * @category generated
 */
class CollectionNotFoundError extends Error {
    constructor() {
        super('Collection Not Found on Metadata');
        this.code = 0x1785;
        this.name = 'CollectionNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionNotFoundError);
        }
    }
}
exports.CollectionNotFoundError = CollectionNotFoundError;
createErrorFromCodeLookup.set(0x1785, () => new CollectionNotFoundError());
createErrorFromNameLookup.set('CollectionNotFound', () => new CollectionNotFoundError());
/**
 * AlreadyVerified: 'Collection item is already verified.'
 *
 * @category Errors
 * @category generated
 */
class AlreadyVerifiedError extends Error {
    constructor() {
        super('Collection item is already verified.');
        this.code = 0x1786;
        this.name = 'AlreadyVerified';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AlreadyVerifiedError);
        }
    }
}
exports.AlreadyVerifiedError = AlreadyVerifiedError;
createErrorFromCodeLookup.set(0x1786, () => new AlreadyVerifiedError());
createErrorFromNameLookup.set('AlreadyVerified', () => new AlreadyVerifiedError());
/**
 * AlreadyUnverified: 'Collection item is already unverified.'
 *
 * @category Errors
 * @category generated
 */
class AlreadyUnverifiedError extends Error {
    constructor() {
        super('Collection item is already unverified.');
        this.code = 0x1787;
        this.name = 'AlreadyUnverified';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AlreadyUnverifiedError);
        }
    }
}
exports.AlreadyUnverifiedError = AlreadyUnverifiedError;
createErrorFromCodeLookup.set(0x1787, () => new AlreadyUnverifiedError());
createErrorFromNameLookup.set('AlreadyUnverified', () => new AlreadyUnverifiedError());
/**
 * UpdateAuthorityIncorrect: 'Incorrect leaf metadata update authority.'
 *
 * @category Errors
 * @category generated
 */
class UpdateAuthorityIncorrectError extends Error {
    constructor() {
        super('Incorrect leaf metadata update authority.');
        this.code = 0x1788;
        this.name = 'UpdateAuthorityIncorrect';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UpdateAuthorityIncorrectError);
        }
    }
}
exports.UpdateAuthorityIncorrectError = UpdateAuthorityIncorrectError;
createErrorFromCodeLookup.set(0x1788, () => new UpdateAuthorityIncorrectError());
createErrorFromNameLookup.set('UpdateAuthorityIncorrect', () => new UpdateAuthorityIncorrectError());
/**
 * LeafAuthorityMustSign: 'This transaction must be signed by either the leaf owner or leaf delegate'
 *
 * @category Errors
 * @category generated
 */
class LeafAuthorityMustSignError extends Error {
    constructor() {
        super('This transaction must be signed by either the leaf owner or leaf delegate');
        this.code = 0x1789;
        this.name = 'LeafAuthorityMustSign';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, LeafAuthorityMustSignError);
        }
    }
}
exports.LeafAuthorityMustSignError = LeafAuthorityMustSignError;
createErrorFromCodeLookup.set(0x1789, () => new LeafAuthorityMustSignError());
createErrorFromNameLookup.set('LeafAuthorityMustSign', () => new LeafAuthorityMustSignError());
/**
 * CollectionMustBeSized: 'Collection Not Compatable with Compression, Must be Sized'
 *
 * @category Errors
 * @category generated
 */
class CollectionMustBeSizedError extends Error {
    constructor() {
        super('Collection Not Compatable with Compression, Must be Sized');
        this.code = 0x178a;
        this.name = 'CollectionMustBeSized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionMustBeSizedError);
        }
    }
}
exports.CollectionMustBeSizedError = CollectionMustBeSizedError;
createErrorFromCodeLookup.set(0x178a, () => new CollectionMustBeSizedError());
createErrorFromNameLookup.set('CollectionMustBeSized', () => new CollectionMustBeSizedError());
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
function errorFromCode(code) {
    const createError = createErrorFromCodeLookup.get(code);
    return createError != null ? createError() : null;
}
exports.errorFromCode = errorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
function errorFromName(name) {
    const createError = createErrorFromNameLookup.get(name);
    return createError != null ? createError() : null;
}
exports.errorFromName = errorFromName;
