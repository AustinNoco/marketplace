"use strict";
/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReservationAlreadyMadeError = exports.ReservationNotSetError = exports.ReservationDoesNotExistError = exports.ReservationExistsError = exports.ShareTotalMustBe100Error = exports.NoBalanceInAccountForAuthorizationError = exports.OwnerMismatchError = exports.PrimarySaleCanOnlyBeFlippedToTrueError = exports.InvalidBasisPointsError = exports.CreatorNotFoundError = exports.NoCreatorsPresentOnMetadataError = exports.MustBeOneOfCreatorsError = exports.CreatorsMustBeAtleastOneError = exports.CreatorsTooLongError = exports.DisabledError = exports.AuthorizationTokenAccountOwnerMismatchError = exports.PrintingMintAuthorizationAccountMismatchError = exports.NotEnoughTokensError = exports.TokenAccountMintMismatchV2Error = exports.TokenAccountMintMismatchError = exports.OneTimePrintingAuthMintMismatchError = exports.PrintingMintMismatchError = exports.DerivedKeyInvalidError = exports.TokenAccountOneTimeAuthMintMismatchError = exports.TokenBurnFailedError = exports.EditionMintDecimalsShouldBeZeroError = exports.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = exports.PrintingMintDecimalsShouldBeZeroError = exports.EditionAlreadyMintedError = exports.DestinationMintMismatchError = exports.MasterRecordMismatchError = exports.TokenMintToFailedError = exports.MaxEditionsMintedAlreadyError = exports.EditionsMustHaveExactlyOneTokenError = exports.MintMismatchError = exports.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = exports.UriTooLongError = exports.SymbolTooLongError = exports.NameTooLongError = exports.InvalidMintAuthorityError = exports.NotMintAuthorityError = exports.UpdateAuthorityIsNotSignerError = exports.UpdateAuthorityIncorrectError = exports.InvalidEditionKeyError = exports.InvalidMetadataKeyError = exports.UninitializedError = exports.AlreadyInitializedError = exports.NotRentExemptError = exports.InstructionPackErrorError = exports.InstructionUnpackErrorError = void 0;
exports.RevokeCollectionAuthoritySignerIncorrectError = exports.InvalidUserError = exports.EditionOverrideCannotBeZeroError = exports.NotAllowedToChangeSellerFeeBasisPointsError = exports.CannotWipeVerifiedCreatorsError = exports.CannotRemoveVerifiedCreatorError = exports.CannotAdjustVerifiedCreatorError = exports.InvalidDelegateError = exports.InvalidFreezeAuthorityError = exports.InvalidCollectionAuthorityRecordError = exports.InvalidUseAuthorityRecordError = exports.CollectionAuthorityDoesNotExistError = exports.CollectionAuthorityRecordAlreadyExistsError = exports.NotEnoughUsesError = exports.UnusableError = exports.UseAuthorityRecordAlreadyRevokedError = exports.UseAuthorityRecordAlreadyExistsError = exports.CollectionMustBeAUniqueMasterEditionError = exports.InvalidCollectionUpdateAuthorityError = exports.CollectionNotFoundError = exports.CannotChangeUsesAfterFirstUseError = exports.CannotChangeUseMethodAfterFirstUseError = exports.InvalidUseMethodError = exports.MustBeBurnedError = exports.RemovedError = exports.CollectionCannotBeVerifiedInThisInstructionError = exports.IsMutableCanOnlyBeFlippedToFalseError = exports.ReservationArrayShouldBeSizeOneError = exports.InvalidEditionIndexError = exports.OneTimeAuthMintSupplyMustBeZeroForConversionError = exports.PrintingMintSupplyMustBeZeroForConversionError = exports.InvalidOwnerError = exports.InvalidOperationError = exports.TriedToReplaceAnExistingReservationError = exports.ReservationNotCompleteError = exports.BeyondAlottedAddressSizeError = exports.DataTypeMismatchError = exports.InvalidTokenProgramError = exports.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = exports.DuplicateCreatorAddressError = exports.DataIsImmutableError = exports.PrintingWouldBreachMaximumSupplyError = exports.IncorrectOwnerError = exports.SpotMismatchError = exports.CannotUnverifyAnotherCreatorError = exports.CannotVerifyAnotherCreatorError = exports.AddressNotInReservationError = exports.ReservationBreachesMaximumSupplyError = exports.NumericalOverflowErrorError = exports.BeyondMaxAddressSizeError = void 0;
exports.MissingSplTokenProgramError = exports.MissingTokenAccountError = exports.OnlySaleDelegateCanTransferError = exports.InvalidSystemWalletError = exports.FeatureNotSupportedError = exports.MissingArgumentInBuilderError = exports.MissingAccountInBuilderError = exports.DelegateNotFoundError = exports.DelegateAlreadyExistsError = exports.InvalidProgrammableConfigError = exports.MissingProgrammableConfigError = exports.MissingAuthorizationRulesError = exports.InvalidAuthorizationRulesError = exports.InvalidMintForTokenStandardError = exports.InvalidTokenStandardError = exports.MintIsNotSignerError = exports.EscrowParentHasDelegateError = exports.InvalidBubblegumSignerError = exports.InvalidCollectionSizeChangeError = exports.NoFreezeAuthoritySetError = exports.BorshSerializationErrorError = exports.InsufficientTokensError = exports.MustBeNonFungibleError = exports.InvalidSystemProgramError = exports.MustBeEscrowAuthorityError = exports.InvalidEscrowBumpSeedError = exports.MustUnverifyError = exports.EditionNumberGreaterThanMaxSupplyError = exports.PrintEditionDoesNotMatchMasterEditionError = exports.ReservationListDeprecatedError = exports.InvalidEditionMarkerError = exports.InvalidPrintEditionError = exports.InvalidMasterEditionError = exports.NotAPrintEditionError = exports.AlreadyUnverifiedError = exports.AlreadyVerifiedError = exports.CollectionMasterEditionAccountInvalidError = exports.CannotUpdateVerifiedCollectionError = exports.BorshDeserializationErrorError = exports.MasterEditionHasPrintsError = exports.NotAMasterEditionError = exports.MissingEditionAccountError = exports.CouldNotDetermineTokenStandardError = exports.NotACollectionParentError = exports.NotVerifiedMemberOfCollectionError = exports.NotAMemberOfCollectionError = exports.MissingCollectionMetadataError = exports.SizedCollectionError = exports.UnsizedCollectionError = exports.TokenCloseFailedError = void 0;
exports.errorFromName = exports.errorFromCode = exports.InvalidTokenRecordError = exports.MissingCollectionMasterEditionError = exports.MissingCollectionMintError = exports.InsufficientTokenBalanceError = exports.InvalidUpdateArgsError = exports.InvalidParentAccountsError = exports.InvalidInstructionsSysvarError = exports.InvalidAssociatedTokenAccountProgramError = exports.MissingEditionError = exports.CannotBurnWithDelegateError = exports.MissingEditionMarkerAccountError = exports.MissingMasterEditionTokenAccountError = exports.MissingMasterEditionMintAccountError = exports.InvalidAmountError = exports.CannotUpdateAssetWithDelegateError = exports.DataIncrementLimitExceededError = exports.InvalidLockedTransferAddressError = exports.MissingLockedTransferAddressError = exports.InvalidDelegateArgsError = exports.AmountMustBeGreaterThanZeroError = exports.MissingMasterEditionAccountError = exports.MissingPrintSupplyError = exports.InvalidDelegateRoleError = exports.IncorrectTokenStateError = exports.InvalidMasterEditionAccountLengthError = exports.MissingTokenOwnerAccountError = exports.DataIsEmptyOrZeroedError = exports.MintSupplyMustBeZeroError = exports.MissingTokenRecordError = exports.InvalidAuthorityTypeError = exports.MissingDelegateRoleError = exports.UnlockedTokenError = exports.LockedTokenError = exports.KeyMismatchError = exports.InstructionNotSupportedError = exports.InvalidTransferAuthorityError = exports.InvalidDelegateRoleForTransferError = exports.MissingAuthorizationRulesProgramError = void 0;
const createErrorFromCodeLookup = new Map();
const createErrorFromNameLookup = new Map();
/**
 * InstructionUnpackError: 'Failed to unpack instruction data'
 *
 * @category Errors
 * @category generated
 */
class InstructionUnpackErrorError extends Error {
    constructor() {
        super('Failed to unpack instruction data');
        this.code = 0x0;
        this.name = 'InstructionUnpackError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InstructionUnpackErrorError);
        }
    }
}
exports.InstructionUnpackErrorError = InstructionUnpackErrorError;
createErrorFromCodeLookup.set(0x0, () => new InstructionUnpackErrorError());
createErrorFromNameLookup.set('InstructionUnpackError', () => new InstructionUnpackErrorError());
/**
 * InstructionPackError: 'Failed to pack instruction data'
 *
 * @category Errors
 * @category generated
 */
class InstructionPackErrorError extends Error {
    constructor() {
        super('Failed to pack instruction data');
        this.code = 0x1;
        this.name = 'InstructionPackError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InstructionPackErrorError);
        }
    }
}
exports.InstructionPackErrorError = InstructionPackErrorError;
createErrorFromCodeLookup.set(0x1, () => new InstructionPackErrorError());
createErrorFromNameLookup.set('InstructionPackError', () => new InstructionPackErrorError());
/**
 * NotRentExempt: 'Lamport balance below rent-exempt threshold'
 *
 * @category Errors
 * @category generated
 */
class NotRentExemptError extends Error {
    constructor() {
        super('Lamport balance below rent-exempt threshold');
        this.code = 0x2;
        this.name = 'NotRentExempt';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotRentExemptError);
        }
    }
}
exports.NotRentExemptError = NotRentExemptError;
createErrorFromCodeLookup.set(0x2, () => new NotRentExemptError());
createErrorFromNameLookup.set('NotRentExempt', () => new NotRentExemptError());
/**
 * AlreadyInitialized: 'Already initialized'
 *
 * @category Errors
 * @category generated
 */
class AlreadyInitializedError extends Error {
    constructor() {
        super('Already initialized');
        this.code = 0x3;
        this.name = 'AlreadyInitialized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AlreadyInitializedError);
        }
    }
}
exports.AlreadyInitializedError = AlreadyInitializedError;
createErrorFromCodeLookup.set(0x3, () => new AlreadyInitializedError());
createErrorFromNameLookup.set('AlreadyInitialized', () => new AlreadyInitializedError());
/**
 * Uninitialized: 'Uninitialized'
 *
 * @category Errors
 * @category generated
 */
class UninitializedError extends Error {
    constructor() {
        super('Uninitialized');
        this.code = 0x4;
        this.name = 'Uninitialized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UninitializedError);
        }
    }
}
exports.UninitializedError = UninitializedError;
createErrorFromCodeLookup.set(0x4, () => new UninitializedError());
createErrorFromNameLookup.set('Uninitialized', () => new UninitializedError());
/**
 * InvalidMetadataKey: ' Metadata's key must match seed of ['metadata', program id, mint] provided'
 *
 * @category Errors
 * @category generated
 */
class InvalidMetadataKeyError extends Error {
    constructor() {
        super(" Metadata's key must match seed of ['metadata', program id, mint] provided");
        this.code = 0x5;
        this.name = 'InvalidMetadataKey';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidMetadataKeyError);
        }
    }
}
exports.InvalidMetadataKeyError = InvalidMetadataKeyError;
createErrorFromCodeLookup.set(0x5, () => new InvalidMetadataKeyError());
createErrorFromNameLookup.set('InvalidMetadataKey', () => new InvalidMetadataKeyError());
/**
 * InvalidEditionKey: 'Edition's key must match seed of ['metadata', program id, name, 'edition'] provided'
 *
 * @category Errors
 * @category generated
 */
class InvalidEditionKeyError extends Error {
    constructor() {
        super("Edition's key must match seed of ['metadata', program id, name, 'edition'] provided");
        this.code = 0x6;
        this.name = 'InvalidEditionKey';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidEditionKeyError);
        }
    }
}
exports.InvalidEditionKeyError = InvalidEditionKeyError;
createErrorFromCodeLookup.set(0x6, () => new InvalidEditionKeyError());
createErrorFromNameLookup.set('InvalidEditionKey', () => new InvalidEditionKeyError());
/**
 * UpdateAuthorityIncorrect: 'Update Authority given does not match'
 *
 * @category Errors
 * @category generated
 */
class UpdateAuthorityIncorrectError extends Error {
    constructor() {
        super('Update Authority given does not match');
        this.code = 0x7;
        this.name = 'UpdateAuthorityIncorrect';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UpdateAuthorityIncorrectError);
        }
    }
}
exports.UpdateAuthorityIncorrectError = UpdateAuthorityIncorrectError;
createErrorFromCodeLookup.set(0x7, () => new UpdateAuthorityIncorrectError());
createErrorFromNameLookup.set('UpdateAuthorityIncorrect', () => new UpdateAuthorityIncorrectError());
/**
 * UpdateAuthorityIsNotSigner: 'Update Authority needs to be signer to update metadata'
 *
 * @category Errors
 * @category generated
 */
class UpdateAuthorityIsNotSignerError extends Error {
    constructor() {
        super('Update Authority needs to be signer to update metadata');
        this.code = 0x8;
        this.name = 'UpdateAuthorityIsNotSigner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UpdateAuthorityIsNotSignerError);
        }
    }
}
exports.UpdateAuthorityIsNotSignerError = UpdateAuthorityIsNotSignerError;
createErrorFromCodeLookup.set(0x8, () => new UpdateAuthorityIsNotSignerError());
createErrorFromNameLookup.set('UpdateAuthorityIsNotSigner', () => new UpdateAuthorityIsNotSignerError());
/**
 * NotMintAuthority: 'You must be the mint authority and signer on this transaction'
 *
 * @category Errors
 * @category generated
 */
class NotMintAuthorityError extends Error {
    constructor() {
        super('You must be the mint authority and signer on this transaction');
        this.code = 0x9;
        this.name = 'NotMintAuthority';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotMintAuthorityError);
        }
    }
}
exports.NotMintAuthorityError = NotMintAuthorityError;
createErrorFromCodeLookup.set(0x9, () => new NotMintAuthorityError());
createErrorFromNameLookup.set('NotMintAuthority', () => new NotMintAuthorityError());
/**
 * InvalidMintAuthority: 'Mint authority provided does not match the authority on the mint'
 *
 * @category Errors
 * @category generated
 */
class InvalidMintAuthorityError extends Error {
    constructor() {
        super('Mint authority provided does not match the authority on the mint');
        this.code = 0xa;
        this.name = 'InvalidMintAuthority';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidMintAuthorityError);
        }
    }
}
exports.InvalidMintAuthorityError = InvalidMintAuthorityError;
createErrorFromCodeLookup.set(0xa, () => new InvalidMintAuthorityError());
createErrorFromNameLookup.set('InvalidMintAuthority', () => new InvalidMintAuthorityError());
/**
 * NameTooLong: 'Name too long'
 *
 * @category Errors
 * @category generated
 */
class NameTooLongError extends Error {
    constructor() {
        super('Name too long');
        this.code = 0xb;
        this.name = 'NameTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NameTooLongError);
        }
    }
}
exports.NameTooLongError = NameTooLongError;
createErrorFromCodeLookup.set(0xb, () => new NameTooLongError());
createErrorFromNameLookup.set('NameTooLong', () => new NameTooLongError());
/**
 * SymbolTooLong: 'Symbol too long'
 *
 * @category Errors
 * @category generated
 */
class SymbolTooLongError extends Error {
    constructor() {
        super('Symbol too long');
        this.code = 0xc;
        this.name = 'SymbolTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SymbolTooLongError);
        }
    }
}
exports.SymbolTooLongError = SymbolTooLongError;
createErrorFromCodeLookup.set(0xc, () => new SymbolTooLongError());
createErrorFromNameLookup.set('SymbolTooLong', () => new SymbolTooLongError());
/**
 * UriTooLong: 'URI too long'
 *
 * @category Errors
 * @category generated
 */
class UriTooLongError extends Error {
    constructor() {
        super('URI too long');
        this.code = 0xd;
        this.name = 'UriTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UriTooLongError);
        }
    }
}
exports.UriTooLongError = UriTooLongError;
createErrorFromCodeLookup.set(0xd, () => new UriTooLongError());
createErrorFromNameLookup.set('UriTooLong', () => new UriTooLongError());
/**
 * UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner: 'Update authority must be equivalent to the metadata's authority and also signer of this transaction'
 *
 * @category Errors
 * @category generated
 */
class UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends Error {
    constructor() {
        super("Update authority must be equivalent to the metadata's authority and also signer of this transaction");
        this.code = 0xe;
        this.name = 'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError);
        }
    }
}
exports.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError;
createErrorFromCodeLookup.set(0xe, () => new UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError());
createErrorFromNameLookup.set('UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner', () => new UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError());
/**
 * MintMismatch: 'Mint given does not match mint on Metadata'
 *
 * @category Errors
 * @category generated
 */
class MintMismatchError extends Error {
    constructor() {
        super('Mint given does not match mint on Metadata');
        this.code = 0xf;
        this.name = 'MintMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MintMismatchError);
        }
    }
}
exports.MintMismatchError = MintMismatchError;
createErrorFromCodeLookup.set(0xf, () => new MintMismatchError());
createErrorFromNameLookup.set('MintMismatch', () => new MintMismatchError());
/**
 * EditionsMustHaveExactlyOneToken: 'Editions must have exactly one token'
 *
 * @category Errors
 * @category generated
 */
class EditionsMustHaveExactlyOneTokenError extends Error {
    constructor() {
        super('Editions must have exactly one token');
        this.code = 0x10;
        this.name = 'EditionsMustHaveExactlyOneToken';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, EditionsMustHaveExactlyOneTokenError);
        }
    }
}
exports.EditionsMustHaveExactlyOneTokenError = EditionsMustHaveExactlyOneTokenError;
createErrorFromCodeLookup.set(0x10, () => new EditionsMustHaveExactlyOneTokenError());
createErrorFromNameLookup.set('EditionsMustHaveExactlyOneToken', () => new EditionsMustHaveExactlyOneTokenError());
/**
 * MaxEditionsMintedAlready: 'Maximum editions printed already'
 *
 * @category Errors
 * @category generated
 */
class MaxEditionsMintedAlreadyError extends Error {
    constructor() {
        super('Maximum editions printed already');
        this.code = 0x11;
        this.name = 'MaxEditionsMintedAlready';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MaxEditionsMintedAlreadyError);
        }
    }
}
exports.MaxEditionsMintedAlreadyError = MaxEditionsMintedAlreadyError;
createErrorFromCodeLookup.set(0x11, () => new MaxEditionsMintedAlreadyError());
createErrorFromNameLookup.set('MaxEditionsMintedAlready', () => new MaxEditionsMintedAlreadyError());
/**
 * TokenMintToFailed: 'Token mint to failed'
 *
 * @category Errors
 * @category generated
 */
class TokenMintToFailedError extends Error {
    constructor() {
        super('Token mint to failed');
        this.code = 0x12;
        this.name = 'TokenMintToFailed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenMintToFailedError);
        }
    }
}
exports.TokenMintToFailedError = TokenMintToFailedError;
createErrorFromCodeLookup.set(0x12, () => new TokenMintToFailedError());
createErrorFromNameLookup.set('TokenMintToFailed', () => new TokenMintToFailedError());
/**
 * MasterRecordMismatch: 'The master edition record passed must match the master record on the edition given'
 *
 * @category Errors
 * @category generated
 */
class MasterRecordMismatchError extends Error {
    constructor() {
        super('The master edition record passed must match the master record on the edition given');
        this.code = 0x13;
        this.name = 'MasterRecordMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MasterRecordMismatchError);
        }
    }
}
exports.MasterRecordMismatchError = MasterRecordMismatchError;
createErrorFromCodeLookup.set(0x13, () => new MasterRecordMismatchError());
createErrorFromNameLookup.set('MasterRecordMismatch', () => new MasterRecordMismatchError());
/**
 * DestinationMintMismatch: 'The destination account does not have the right mint'
 *
 * @category Errors
 * @category generated
 */
class DestinationMintMismatchError extends Error {
    constructor() {
        super('The destination account does not have the right mint');
        this.code = 0x14;
        this.name = 'DestinationMintMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DestinationMintMismatchError);
        }
    }
}
exports.DestinationMintMismatchError = DestinationMintMismatchError;
createErrorFromCodeLookup.set(0x14, () => new DestinationMintMismatchError());
createErrorFromNameLookup.set('DestinationMintMismatch', () => new DestinationMintMismatchError());
/**
 * EditionAlreadyMinted: 'An edition can only mint one of its kind!'
 *
 * @category Errors
 * @category generated
 */
class EditionAlreadyMintedError extends Error {
    constructor() {
        super('An edition can only mint one of its kind!');
        this.code = 0x15;
        this.name = 'EditionAlreadyMinted';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, EditionAlreadyMintedError);
        }
    }
}
exports.EditionAlreadyMintedError = EditionAlreadyMintedError;
createErrorFromCodeLookup.set(0x15, () => new EditionAlreadyMintedError());
createErrorFromNameLookup.set('EditionAlreadyMinted', () => new EditionAlreadyMintedError());
/**
 * PrintingMintDecimalsShouldBeZero: 'Printing mint decimals should be zero'
 *
 * @category Errors
 * @category generated
 */
class PrintingMintDecimalsShouldBeZeroError extends Error {
    constructor() {
        super('Printing mint decimals should be zero');
        this.code = 0x16;
        this.name = 'PrintingMintDecimalsShouldBeZero';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrintingMintDecimalsShouldBeZeroError);
        }
    }
}
exports.PrintingMintDecimalsShouldBeZeroError = PrintingMintDecimalsShouldBeZeroError;
createErrorFromCodeLookup.set(0x16, () => new PrintingMintDecimalsShouldBeZeroError());
createErrorFromNameLookup.set('PrintingMintDecimalsShouldBeZero', () => new PrintingMintDecimalsShouldBeZeroError());
/**
 * OneTimePrintingAuthorizationMintDecimalsShouldBeZero: 'OneTimePrintingAuthorization mint decimals should be zero'
 *
 * @category Errors
 * @category generated
 */
class OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends Error {
    constructor() {
        super('OneTimePrintingAuthorization mint decimals should be zero');
        this.code = 0x17;
        this.name = 'OneTimePrintingAuthorizationMintDecimalsShouldBeZero';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError);
        }
    }
}
exports.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError;
createErrorFromCodeLookup.set(0x17, () => new OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError());
createErrorFromNameLookup.set('OneTimePrintingAuthorizationMintDecimalsShouldBeZero', () => new OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError());
/**
 * EditionMintDecimalsShouldBeZero: 'EditionMintDecimalsShouldBeZero'
 *
 * @category Errors
 * @category generated
 */
class EditionMintDecimalsShouldBeZeroError extends Error {
    constructor() {
        super('EditionMintDecimalsShouldBeZero');
        this.code = 0x18;
        this.name = 'EditionMintDecimalsShouldBeZero';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, EditionMintDecimalsShouldBeZeroError);
        }
    }
}
exports.EditionMintDecimalsShouldBeZeroError = EditionMintDecimalsShouldBeZeroError;
createErrorFromCodeLookup.set(0x18, () => new EditionMintDecimalsShouldBeZeroError());
createErrorFromNameLookup.set('EditionMintDecimalsShouldBeZero', () => new EditionMintDecimalsShouldBeZeroError());
/**
 * TokenBurnFailed: 'Token burn failed'
 *
 * @category Errors
 * @category generated
 */
class TokenBurnFailedError extends Error {
    constructor() {
        super('Token burn failed');
        this.code = 0x19;
        this.name = 'TokenBurnFailed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenBurnFailedError);
        }
    }
}
exports.TokenBurnFailedError = TokenBurnFailedError;
createErrorFromCodeLookup.set(0x19, () => new TokenBurnFailedError());
createErrorFromNameLookup.set('TokenBurnFailed', () => new TokenBurnFailedError());
/**
 * TokenAccountOneTimeAuthMintMismatch: 'The One Time authorization mint does not match that on the token account!'
 *
 * @category Errors
 * @category generated
 */
class TokenAccountOneTimeAuthMintMismatchError extends Error {
    constructor() {
        super('The One Time authorization mint does not match that on the token account!');
        this.code = 0x1a;
        this.name = 'TokenAccountOneTimeAuthMintMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenAccountOneTimeAuthMintMismatchError);
        }
    }
}
exports.TokenAccountOneTimeAuthMintMismatchError = TokenAccountOneTimeAuthMintMismatchError;
createErrorFromCodeLookup.set(0x1a, () => new TokenAccountOneTimeAuthMintMismatchError());
createErrorFromNameLookup.set('TokenAccountOneTimeAuthMintMismatch', () => new TokenAccountOneTimeAuthMintMismatchError());
/**
 * DerivedKeyInvalid: 'Derived key invalid'
 *
 * @category Errors
 * @category generated
 */
class DerivedKeyInvalidError extends Error {
    constructor() {
        super('Derived key invalid');
        this.code = 0x1b;
        this.name = 'DerivedKeyInvalid';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DerivedKeyInvalidError);
        }
    }
}
exports.DerivedKeyInvalidError = DerivedKeyInvalidError;
createErrorFromCodeLookup.set(0x1b, () => new DerivedKeyInvalidError());
createErrorFromNameLookup.set('DerivedKeyInvalid', () => new DerivedKeyInvalidError());
/**
 * PrintingMintMismatch: 'The Printing mint does not match that on the master edition!'
 *
 * @category Errors
 * @category generated
 */
class PrintingMintMismatchError extends Error {
    constructor() {
        super('The Printing mint does not match that on the master edition!');
        this.code = 0x1c;
        this.name = 'PrintingMintMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrintingMintMismatchError);
        }
    }
}
exports.PrintingMintMismatchError = PrintingMintMismatchError;
createErrorFromCodeLookup.set(0x1c, () => new PrintingMintMismatchError());
createErrorFromNameLookup.set('PrintingMintMismatch', () => new PrintingMintMismatchError());
/**
 * OneTimePrintingAuthMintMismatch: 'The One Time Printing Auth mint does not match that on the master edition!'
 *
 * @category Errors
 * @category generated
 */
class OneTimePrintingAuthMintMismatchError extends Error {
    constructor() {
        super('The One Time Printing Auth mint does not match that on the master edition!');
        this.code = 0x1d;
        this.name = 'OneTimePrintingAuthMintMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, OneTimePrintingAuthMintMismatchError);
        }
    }
}
exports.OneTimePrintingAuthMintMismatchError = OneTimePrintingAuthMintMismatchError;
createErrorFromCodeLookup.set(0x1d, () => new OneTimePrintingAuthMintMismatchError());
createErrorFromNameLookup.set('OneTimePrintingAuthMintMismatch', () => new OneTimePrintingAuthMintMismatchError());
/**
 * TokenAccountMintMismatch: 'The mint of the token account does not match the Printing mint!'
 *
 * @category Errors
 * @category generated
 */
class TokenAccountMintMismatchError extends Error {
    constructor() {
        super('The mint of the token account does not match the Printing mint!');
        this.code = 0x1e;
        this.name = 'TokenAccountMintMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenAccountMintMismatchError);
        }
    }
}
exports.TokenAccountMintMismatchError = TokenAccountMintMismatchError;
createErrorFromCodeLookup.set(0x1e, () => new TokenAccountMintMismatchError());
createErrorFromNameLookup.set('TokenAccountMintMismatch', () => new TokenAccountMintMismatchError());
/**
 * TokenAccountMintMismatchV2: 'The mint of the token account does not match the master metadata mint!'
 *
 * @category Errors
 * @category generated
 */
class TokenAccountMintMismatchV2Error extends Error {
    constructor() {
        super('The mint of the token account does not match the master metadata mint!');
        this.code = 0x1f;
        this.name = 'TokenAccountMintMismatchV2';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenAccountMintMismatchV2Error);
        }
    }
}
exports.TokenAccountMintMismatchV2Error = TokenAccountMintMismatchV2Error;
createErrorFromCodeLookup.set(0x1f, () => new TokenAccountMintMismatchV2Error());
createErrorFromNameLookup.set('TokenAccountMintMismatchV2', () => new TokenAccountMintMismatchV2Error());
/**
 * NotEnoughTokens: 'Not enough tokens to mint a limited edition'
 *
 * @category Errors
 * @category generated
 */
class NotEnoughTokensError extends Error {
    constructor() {
        super('Not enough tokens to mint a limited edition');
        this.code = 0x20;
        this.name = 'NotEnoughTokens';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotEnoughTokensError);
        }
    }
}
exports.NotEnoughTokensError = NotEnoughTokensError;
createErrorFromCodeLookup.set(0x20, () => new NotEnoughTokensError());
createErrorFromNameLookup.set('NotEnoughTokens', () => new NotEnoughTokensError());
/**
 * PrintingMintAuthorizationAccountMismatch: 'The mint on your authorization token holding account does not match your Printing mint!'
 *
 * @category Errors
 * @category generated
 */
class PrintingMintAuthorizationAccountMismatchError extends Error {
    constructor() {
        super('The mint on your authorization token holding account does not match your Printing mint!');
        this.code = 0x21;
        this.name = 'PrintingMintAuthorizationAccountMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrintingMintAuthorizationAccountMismatchError);
        }
    }
}
exports.PrintingMintAuthorizationAccountMismatchError = PrintingMintAuthorizationAccountMismatchError;
createErrorFromCodeLookup.set(0x21, () => new PrintingMintAuthorizationAccountMismatchError());
createErrorFromNameLookup.set('PrintingMintAuthorizationAccountMismatch', () => new PrintingMintAuthorizationAccountMismatchError());
/**
 * AuthorizationTokenAccountOwnerMismatch: 'The authorization token account has a different owner than the update authority for the master edition!'
 *
 * @category Errors
 * @category generated
 */
class AuthorizationTokenAccountOwnerMismatchError extends Error {
    constructor() {
        super('The authorization token account has a different owner than the update authority for the master edition!');
        this.code = 0x22;
        this.name = 'AuthorizationTokenAccountOwnerMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AuthorizationTokenAccountOwnerMismatchError);
        }
    }
}
exports.AuthorizationTokenAccountOwnerMismatchError = AuthorizationTokenAccountOwnerMismatchError;
createErrorFromCodeLookup.set(0x22, () => new AuthorizationTokenAccountOwnerMismatchError());
createErrorFromNameLookup.set('AuthorizationTokenAccountOwnerMismatch', () => new AuthorizationTokenAccountOwnerMismatchError());
/**
 * Disabled: 'This feature is currently disabled.'
 *
 * @category Errors
 * @category generated
 */
class DisabledError extends Error {
    constructor() {
        super('This feature is currently disabled.');
        this.code = 0x23;
        this.name = 'Disabled';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DisabledError);
        }
    }
}
exports.DisabledError = DisabledError;
createErrorFromCodeLookup.set(0x23, () => new DisabledError());
createErrorFromNameLookup.set('Disabled', () => new DisabledError());
/**
 * CreatorsTooLong: 'Creators list too long'
 *
 * @category Errors
 * @category generated
 */
class CreatorsTooLongError extends Error {
    constructor() {
        super('Creators list too long');
        this.code = 0x24;
        this.name = 'CreatorsTooLong';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorsTooLongError);
        }
    }
}
exports.CreatorsTooLongError = CreatorsTooLongError;
createErrorFromCodeLookup.set(0x24, () => new CreatorsTooLongError());
createErrorFromNameLookup.set('CreatorsTooLong', () => new CreatorsTooLongError());
/**
 * CreatorsMustBeAtleastOne: 'Creators must be at least one if set'
 *
 * @category Errors
 * @category generated
 */
class CreatorsMustBeAtleastOneError extends Error {
    constructor() {
        super('Creators must be at least one if set');
        this.code = 0x25;
        this.name = 'CreatorsMustBeAtleastOne';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorsMustBeAtleastOneError);
        }
    }
}
exports.CreatorsMustBeAtleastOneError = CreatorsMustBeAtleastOneError;
createErrorFromCodeLookup.set(0x25, () => new CreatorsMustBeAtleastOneError());
createErrorFromNameLookup.set('CreatorsMustBeAtleastOne', () => new CreatorsMustBeAtleastOneError());
/**
 * MustBeOneOfCreators: 'If using a creators array, you must be one of the creators listed'
 *
 * @category Errors
 * @category generated
 */
class MustBeOneOfCreatorsError extends Error {
    constructor() {
        super('If using a creators array, you must be one of the creators listed');
        this.code = 0x26;
        this.name = 'MustBeOneOfCreators';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MustBeOneOfCreatorsError);
        }
    }
}
exports.MustBeOneOfCreatorsError = MustBeOneOfCreatorsError;
createErrorFromCodeLookup.set(0x26, () => new MustBeOneOfCreatorsError());
createErrorFromNameLookup.set('MustBeOneOfCreators', () => new MustBeOneOfCreatorsError());
/**
 * NoCreatorsPresentOnMetadata: 'This metadata does not have creators'
 *
 * @category Errors
 * @category generated
 */
class NoCreatorsPresentOnMetadataError extends Error {
    constructor() {
        super('This metadata does not have creators');
        this.code = 0x27;
        this.name = 'NoCreatorsPresentOnMetadata';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NoCreatorsPresentOnMetadataError);
        }
    }
}
exports.NoCreatorsPresentOnMetadataError = NoCreatorsPresentOnMetadataError;
createErrorFromCodeLookup.set(0x27, () => new NoCreatorsPresentOnMetadataError());
createErrorFromNameLookup.set('NoCreatorsPresentOnMetadata', () => new NoCreatorsPresentOnMetadataError());
/**
 * CreatorNotFound: 'This creator address was not found'
 *
 * @category Errors
 * @category generated
 */
class CreatorNotFoundError extends Error {
    constructor() {
        super('This creator address was not found');
        this.code = 0x28;
        this.name = 'CreatorNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CreatorNotFoundError);
        }
    }
}
exports.CreatorNotFoundError = CreatorNotFoundError;
createErrorFromCodeLookup.set(0x28, () => new CreatorNotFoundError());
createErrorFromNameLookup.set('CreatorNotFound', () => new CreatorNotFoundError());
/**
 * InvalidBasisPoints: 'Basis points cannot be more than 10000'
 *
 * @category Errors
 * @category generated
 */
class InvalidBasisPointsError extends Error {
    constructor() {
        super('Basis points cannot be more than 10000');
        this.code = 0x29;
        this.name = 'InvalidBasisPoints';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidBasisPointsError);
        }
    }
}
exports.InvalidBasisPointsError = InvalidBasisPointsError;
createErrorFromCodeLookup.set(0x29, () => new InvalidBasisPointsError());
createErrorFromNameLookup.set('InvalidBasisPoints', () => new InvalidBasisPointsError());
/**
 * PrimarySaleCanOnlyBeFlippedToTrue: 'Primary sale can only be flipped to true and is immutable'
 *
 * @category Errors
 * @category generated
 */
class PrimarySaleCanOnlyBeFlippedToTrueError extends Error {
    constructor() {
        super('Primary sale can only be flipped to true and is immutable');
        this.code = 0x2a;
        this.name = 'PrimarySaleCanOnlyBeFlippedToTrue';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrimarySaleCanOnlyBeFlippedToTrueError);
        }
    }
}
exports.PrimarySaleCanOnlyBeFlippedToTrueError = PrimarySaleCanOnlyBeFlippedToTrueError;
createErrorFromCodeLookup.set(0x2a, () => new PrimarySaleCanOnlyBeFlippedToTrueError());
createErrorFromNameLookup.set('PrimarySaleCanOnlyBeFlippedToTrue', () => new PrimarySaleCanOnlyBeFlippedToTrueError());
/**
 * OwnerMismatch: 'Owner does not match that on the account given'
 *
 * @category Errors
 * @category generated
 */
class OwnerMismatchError extends Error {
    constructor() {
        super('Owner does not match that on the account given');
        this.code = 0x2b;
        this.name = 'OwnerMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, OwnerMismatchError);
        }
    }
}
exports.OwnerMismatchError = OwnerMismatchError;
createErrorFromCodeLookup.set(0x2b, () => new OwnerMismatchError());
createErrorFromNameLookup.set('OwnerMismatch', () => new OwnerMismatchError());
/**
 * NoBalanceInAccountForAuthorization: 'This account has no tokens to be used for authorization'
 *
 * @category Errors
 * @category generated
 */
class NoBalanceInAccountForAuthorizationError extends Error {
    constructor() {
        super('This account has no tokens to be used for authorization');
        this.code = 0x2c;
        this.name = 'NoBalanceInAccountForAuthorization';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NoBalanceInAccountForAuthorizationError);
        }
    }
}
exports.NoBalanceInAccountForAuthorizationError = NoBalanceInAccountForAuthorizationError;
createErrorFromCodeLookup.set(0x2c, () => new NoBalanceInAccountForAuthorizationError());
createErrorFromNameLookup.set('NoBalanceInAccountForAuthorization', () => new NoBalanceInAccountForAuthorizationError());
/**
 * ShareTotalMustBe100: 'Share total must equal 100 for creator array'
 *
 * @category Errors
 * @category generated
 */
class ShareTotalMustBe100Error extends Error {
    constructor() {
        super('Share total must equal 100 for creator array');
        this.code = 0x2d;
        this.name = 'ShareTotalMustBe100';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ShareTotalMustBe100Error);
        }
    }
}
exports.ShareTotalMustBe100Error = ShareTotalMustBe100Error;
createErrorFromCodeLookup.set(0x2d, () => new ShareTotalMustBe100Error());
createErrorFromNameLookup.set('ShareTotalMustBe100', () => new ShareTotalMustBe100Error());
/**
 * ReservationExists: 'This reservation list already exists!'
 *
 * @category Errors
 * @category generated
 */
class ReservationExistsError extends Error {
    constructor() {
        super('This reservation list already exists!');
        this.code = 0x2e;
        this.name = 'ReservationExists';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationExistsError);
        }
    }
}
exports.ReservationExistsError = ReservationExistsError;
createErrorFromCodeLookup.set(0x2e, () => new ReservationExistsError());
createErrorFromNameLookup.set('ReservationExists', () => new ReservationExistsError());
/**
 * ReservationDoesNotExist: 'This reservation list does not exist!'
 *
 * @category Errors
 * @category generated
 */
class ReservationDoesNotExistError extends Error {
    constructor() {
        super('This reservation list does not exist!');
        this.code = 0x2f;
        this.name = 'ReservationDoesNotExist';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationDoesNotExistError);
        }
    }
}
exports.ReservationDoesNotExistError = ReservationDoesNotExistError;
createErrorFromCodeLookup.set(0x2f, () => new ReservationDoesNotExistError());
createErrorFromNameLookup.set('ReservationDoesNotExist', () => new ReservationDoesNotExistError());
/**
 * ReservationNotSet: 'This reservation list exists but was never set with reservations'
 *
 * @category Errors
 * @category generated
 */
class ReservationNotSetError extends Error {
    constructor() {
        super('This reservation list exists but was never set with reservations');
        this.code = 0x30;
        this.name = 'ReservationNotSet';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationNotSetError);
        }
    }
}
exports.ReservationNotSetError = ReservationNotSetError;
createErrorFromCodeLookup.set(0x30, () => new ReservationNotSetError());
createErrorFromNameLookup.set('ReservationNotSet', () => new ReservationNotSetError());
/**
 * ReservationAlreadyMade: 'This reservation list has already been set!'
 *
 * @category Errors
 * @category generated
 */
class ReservationAlreadyMadeError extends Error {
    constructor() {
        super('This reservation list has already been set!');
        this.code = 0x31;
        this.name = 'ReservationAlreadyMade';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationAlreadyMadeError);
        }
    }
}
exports.ReservationAlreadyMadeError = ReservationAlreadyMadeError;
createErrorFromCodeLookup.set(0x31, () => new ReservationAlreadyMadeError());
createErrorFromNameLookup.set('ReservationAlreadyMade', () => new ReservationAlreadyMadeError());
/**
 * BeyondMaxAddressSize: 'Provided more addresses than max allowed in single reservation'
 *
 * @category Errors
 * @category generated
 */
class BeyondMaxAddressSizeError extends Error {
    constructor() {
        super('Provided more addresses than max allowed in single reservation');
        this.code = 0x32;
        this.name = 'BeyondMaxAddressSize';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, BeyondMaxAddressSizeError);
        }
    }
}
exports.BeyondMaxAddressSizeError = BeyondMaxAddressSizeError;
createErrorFromCodeLookup.set(0x32, () => new BeyondMaxAddressSizeError());
createErrorFromNameLookup.set('BeyondMaxAddressSize', () => new BeyondMaxAddressSizeError());
/**
 * NumericalOverflowError: 'NumericalOverflowError'
 *
 * @category Errors
 * @category generated
 */
class NumericalOverflowErrorError extends Error {
    constructor() {
        super('NumericalOverflowError');
        this.code = 0x33;
        this.name = 'NumericalOverflowError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NumericalOverflowErrorError);
        }
    }
}
exports.NumericalOverflowErrorError = NumericalOverflowErrorError;
createErrorFromCodeLookup.set(0x33, () => new NumericalOverflowErrorError());
createErrorFromNameLookup.set('NumericalOverflowError', () => new NumericalOverflowErrorError());
/**
 * ReservationBreachesMaximumSupply: 'This reservation would go beyond the maximum supply of the master edition!'
 *
 * @category Errors
 * @category generated
 */
class ReservationBreachesMaximumSupplyError extends Error {
    constructor() {
        super('This reservation would go beyond the maximum supply of the master edition!');
        this.code = 0x34;
        this.name = 'ReservationBreachesMaximumSupply';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationBreachesMaximumSupplyError);
        }
    }
}
exports.ReservationBreachesMaximumSupplyError = ReservationBreachesMaximumSupplyError;
createErrorFromCodeLookup.set(0x34, () => new ReservationBreachesMaximumSupplyError());
createErrorFromNameLookup.set('ReservationBreachesMaximumSupply', () => new ReservationBreachesMaximumSupplyError());
/**
 * AddressNotInReservation: 'Address not in reservation!'
 *
 * @category Errors
 * @category generated
 */
class AddressNotInReservationError extends Error {
    constructor() {
        super('Address not in reservation!');
        this.code = 0x35;
        this.name = 'AddressNotInReservation';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AddressNotInReservationError);
        }
    }
}
exports.AddressNotInReservationError = AddressNotInReservationError;
createErrorFromCodeLookup.set(0x35, () => new AddressNotInReservationError());
createErrorFromNameLookup.set('AddressNotInReservation', () => new AddressNotInReservationError());
/**
 * CannotVerifyAnotherCreator: 'You cannot unilaterally verify another creator, they must sign'
 *
 * @category Errors
 * @category generated
 */
class CannotVerifyAnotherCreatorError extends Error {
    constructor() {
        super('You cannot unilaterally verify another creator, they must sign');
        this.code = 0x36;
        this.name = 'CannotVerifyAnotherCreator';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotVerifyAnotherCreatorError);
        }
    }
}
exports.CannotVerifyAnotherCreatorError = CannotVerifyAnotherCreatorError;
createErrorFromCodeLookup.set(0x36, () => new CannotVerifyAnotherCreatorError());
createErrorFromNameLookup.set('CannotVerifyAnotherCreator', () => new CannotVerifyAnotherCreatorError());
/**
 * CannotUnverifyAnotherCreator: 'You cannot unilaterally unverify another creator'
 *
 * @category Errors
 * @category generated
 */
class CannotUnverifyAnotherCreatorError extends Error {
    constructor() {
        super('You cannot unilaterally unverify another creator');
        this.code = 0x37;
        this.name = 'CannotUnverifyAnotherCreator';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotUnverifyAnotherCreatorError);
        }
    }
}
exports.CannotUnverifyAnotherCreatorError = CannotUnverifyAnotherCreatorError;
createErrorFromCodeLookup.set(0x37, () => new CannotUnverifyAnotherCreatorError());
createErrorFromNameLookup.set('CannotUnverifyAnotherCreator', () => new CannotUnverifyAnotherCreatorError());
/**
 * SpotMismatch: 'In initial reservation setting, spots remaining should equal total spots'
 *
 * @category Errors
 * @category generated
 */
class SpotMismatchError extends Error {
    constructor() {
        super('In initial reservation setting, spots remaining should equal total spots');
        this.code = 0x38;
        this.name = 'SpotMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SpotMismatchError);
        }
    }
}
exports.SpotMismatchError = SpotMismatchError;
createErrorFromCodeLookup.set(0x38, () => new SpotMismatchError());
createErrorFromNameLookup.set('SpotMismatch', () => new SpotMismatchError());
/**
 * IncorrectOwner: 'Incorrect account owner'
 *
 * @category Errors
 * @category generated
 */
class IncorrectOwnerError extends Error {
    constructor() {
        super('Incorrect account owner');
        this.code = 0x39;
        this.name = 'IncorrectOwner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, IncorrectOwnerError);
        }
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
createErrorFromCodeLookup.set(0x39, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());
/**
 * PrintingWouldBreachMaximumSupply: 'printing these tokens would breach the maximum supply limit of the master edition'
 *
 * @category Errors
 * @category generated
 */
class PrintingWouldBreachMaximumSupplyError extends Error {
    constructor() {
        super('printing these tokens would breach the maximum supply limit of the master edition');
        this.code = 0x3a;
        this.name = 'PrintingWouldBreachMaximumSupply';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrintingWouldBreachMaximumSupplyError);
        }
    }
}
exports.PrintingWouldBreachMaximumSupplyError = PrintingWouldBreachMaximumSupplyError;
createErrorFromCodeLookup.set(0x3a, () => new PrintingWouldBreachMaximumSupplyError());
createErrorFromNameLookup.set('PrintingWouldBreachMaximumSupply', () => new PrintingWouldBreachMaximumSupplyError());
/**
 * DataIsImmutable: 'Data is immutable'
 *
 * @category Errors
 * @category generated
 */
class DataIsImmutableError extends Error {
    constructor() {
        super('Data is immutable');
        this.code = 0x3b;
        this.name = 'DataIsImmutable';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DataIsImmutableError);
        }
    }
}
exports.DataIsImmutableError = DataIsImmutableError;
createErrorFromCodeLookup.set(0x3b, () => new DataIsImmutableError());
createErrorFromNameLookup.set('DataIsImmutable', () => new DataIsImmutableError());
/**
 * DuplicateCreatorAddress: 'No duplicate creator addresses'
 *
 * @category Errors
 * @category generated
 */
class DuplicateCreatorAddressError extends Error {
    constructor() {
        super('No duplicate creator addresses');
        this.code = 0x3c;
        this.name = 'DuplicateCreatorAddress';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DuplicateCreatorAddressError);
        }
    }
}
exports.DuplicateCreatorAddressError = DuplicateCreatorAddressError;
createErrorFromCodeLookup.set(0x3c, () => new DuplicateCreatorAddressError());
createErrorFromNameLookup.set('DuplicateCreatorAddress', () => new DuplicateCreatorAddressError());
/**
 * ReservationSpotsRemainingShouldMatchTotalSpotsAtStart: 'Reservation spots remaining should match total spots when first being created'
 *
 * @category Errors
 * @category generated
 */
class ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends Error {
    constructor() {
        super('Reservation spots remaining should match total spots when first being created');
        this.code = 0x3d;
        this.name = 'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError);
        }
    }
}
exports.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError;
createErrorFromCodeLookup.set(0x3d, () => new ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError());
createErrorFromNameLookup.set('ReservationSpotsRemainingShouldMatchTotalSpotsAtStart', () => new ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError());
/**
 * InvalidTokenProgram: 'Invalid token program'
 *
 * @category Errors
 * @category generated
 */
class InvalidTokenProgramError extends Error {
    constructor() {
        super('Invalid token program');
        this.code = 0x3e;
        this.name = 'InvalidTokenProgram';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidTokenProgramError);
        }
    }
}
exports.InvalidTokenProgramError = InvalidTokenProgramError;
createErrorFromCodeLookup.set(0x3e, () => new InvalidTokenProgramError());
createErrorFromNameLookup.set('InvalidTokenProgram', () => new InvalidTokenProgramError());
/**
 * DataTypeMismatch: 'Data type mismatch'
 *
 * @category Errors
 * @category generated
 */
class DataTypeMismatchError extends Error {
    constructor() {
        super('Data type mismatch');
        this.code = 0x3f;
        this.name = 'DataTypeMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DataTypeMismatchError);
        }
    }
}
exports.DataTypeMismatchError = DataTypeMismatchError;
createErrorFromCodeLookup.set(0x3f, () => new DataTypeMismatchError());
createErrorFromNameLookup.set('DataTypeMismatch', () => new DataTypeMismatchError());
/**
 * BeyondAlottedAddressSize: 'Beyond alotted address size in reservation!'
 *
 * @category Errors
 * @category generated
 */
class BeyondAlottedAddressSizeError extends Error {
    constructor() {
        super('Beyond alotted address size in reservation!');
        this.code = 0x40;
        this.name = 'BeyondAlottedAddressSize';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, BeyondAlottedAddressSizeError);
        }
    }
}
exports.BeyondAlottedAddressSizeError = BeyondAlottedAddressSizeError;
createErrorFromCodeLookup.set(0x40, () => new BeyondAlottedAddressSizeError());
createErrorFromNameLookup.set('BeyondAlottedAddressSize', () => new BeyondAlottedAddressSizeError());
/**
 * ReservationNotComplete: 'The reservation has only been partially alotted'
 *
 * @category Errors
 * @category generated
 */
class ReservationNotCompleteError extends Error {
    constructor() {
        super('The reservation has only been partially alotted');
        this.code = 0x41;
        this.name = 'ReservationNotComplete';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationNotCompleteError);
        }
    }
}
exports.ReservationNotCompleteError = ReservationNotCompleteError;
createErrorFromCodeLookup.set(0x41, () => new ReservationNotCompleteError());
createErrorFromNameLookup.set('ReservationNotComplete', () => new ReservationNotCompleteError());
/**
 * TriedToReplaceAnExistingReservation: 'You cannot splice over an existing reservation!'
 *
 * @category Errors
 * @category generated
 */
class TriedToReplaceAnExistingReservationError extends Error {
    constructor() {
        super('You cannot splice over an existing reservation!');
        this.code = 0x42;
        this.name = 'TriedToReplaceAnExistingReservation';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TriedToReplaceAnExistingReservationError);
        }
    }
}
exports.TriedToReplaceAnExistingReservationError = TriedToReplaceAnExistingReservationError;
createErrorFromCodeLookup.set(0x42, () => new TriedToReplaceAnExistingReservationError());
createErrorFromNameLookup.set('TriedToReplaceAnExistingReservation', () => new TriedToReplaceAnExistingReservationError());
/**
 * InvalidOperation: 'Invalid operation'
 *
 * @category Errors
 * @category generated
 */
class InvalidOperationError extends Error {
    constructor() {
        super('Invalid operation');
        this.code = 0x43;
        this.name = 'InvalidOperation';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidOperationError);
        }
    }
}
exports.InvalidOperationError = InvalidOperationError;
createErrorFromCodeLookup.set(0x43, () => new InvalidOperationError());
createErrorFromNameLookup.set('InvalidOperation', () => new InvalidOperationError());
/**
 * InvalidOwner: 'Invalid Owner'
 *
 * @category Errors
 * @category generated
 */
class InvalidOwnerError extends Error {
    constructor() {
        super('Invalid Owner');
        this.code = 0x44;
        this.name = 'InvalidOwner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidOwnerError);
        }
    }
}
exports.InvalidOwnerError = InvalidOwnerError;
createErrorFromCodeLookup.set(0x44, () => new InvalidOwnerError());
createErrorFromNameLookup.set('InvalidOwner', () => new InvalidOwnerError());
/**
 * PrintingMintSupplyMustBeZeroForConversion: 'Printing mint supply must be zero for conversion'
 *
 * @category Errors
 * @category generated
 */
class PrintingMintSupplyMustBeZeroForConversionError extends Error {
    constructor() {
        super('Printing mint supply must be zero for conversion');
        this.code = 0x45;
        this.name = 'PrintingMintSupplyMustBeZeroForConversion';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrintingMintSupplyMustBeZeroForConversionError);
        }
    }
}
exports.PrintingMintSupplyMustBeZeroForConversionError = PrintingMintSupplyMustBeZeroForConversionError;
createErrorFromCodeLookup.set(0x45, () => new PrintingMintSupplyMustBeZeroForConversionError());
createErrorFromNameLookup.set('PrintingMintSupplyMustBeZeroForConversion', () => new PrintingMintSupplyMustBeZeroForConversionError());
/**
 * OneTimeAuthMintSupplyMustBeZeroForConversion: 'One Time Auth mint supply must be zero for conversion'
 *
 * @category Errors
 * @category generated
 */
class OneTimeAuthMintSupplyMustBeZeroForConversionError extends Error {
    constructor() {
        super('One Time Auth mint supply must be zero for conversion');
        this.code = 0x46;
        this.name = 'OneTimeAuthMintSupplyMustBeZeroForConversion';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, OneTimeAuthMintSupplyMustBeZeroForConversionError);
        }
    }
}
exports.OneTimeAuthMintSupplyMustBeZeroForConversionError = OneTimeAuthMintSupplyMustBeZeroForConversionError;
createErrorFromCodeLookup.set(0x46, () => new OneTimeAuthMintSupplyMustBeZeroForConversionError());
createErrorFromNameLookup.set('OneTimeAuthMintSupplyMustBeZeroForConversion', () => new OneTimeAuthMintSupplyMustBeZeroForConversionError());
/**
 * InvalidEditionIndex: 'You tried to insert one edition too many into an edition mark pda'
 *
 * @category Errors
 * @category generated
 */
class InvalidEditionIndexError extends Error {
    constructor() {
        super('You tried to insert one edition too many into an edition mark pda');
        this.code = 0x47;
        this.name = 'InvalidEditionIndex';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidEditionIndexError);
        }
    }
}
exports.InvalidEditionIndexError = InvalidEditionIndexError;
createErrorFromCodeLookup.set(0x47, () => new InvalidEditionIndexError());
createErrorFromNameLookup.set('InvalidEditionIndex', () => new InvalidEditionIndexError());
/**
 * ReservationArrayShouldBeSizeOne: 'In the legacy system the reservation needs to be of size one for cpu limit reasons'
 *
 * @category Errors
 * @category generated
 */
class ReservationArrayShouldBeSizeOneError extends Error {
    constructor() {
        super('In the legacy system the reservation needs to be of size one for cpu limit reasons');
        this.code = 0x48;
        this.name = 'ReservationArrayShouldBeSizeOne';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationArrayShouldBeSizeOneError);
        }
    }
}
exports.ReservationArrayShouldBeSizeOneError = ReservationArrayShouldBeSizeOneError;
createErrorFromCodeLookup.set(0x48, () => new ReservationArrayShouldBeSizeOneError());
createErrorFromNameLookup.set('ReservationArrayShouldBeSizeOne', () => new ReservationArrayShouldBeSizeOneError());
/**
 * IsMutableCanOnlyBeFlippedToFalse: 'Is Mutable can only be flipped to false'
 *
 * @category Errors
 * @category generated
 */
class IsMutableCanOnlyBeFlippedToFalseError extends Error {
    constructor() {
        super('Is Mutable can only be flipped to false');
        this.code = 0x49;
        this.name = 'IsMutableCanOnlyBeFlippedToFalse';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, IsMutableCanOnlyBeFlippedToFalseError);
        }
    }
}
exports.IsMutableCanOnlyBeFlippedToFalseError = IsMutableCanOnlyBeFlippedToFalseError;
createErrorFromCodeLookup.set(0x49, () => new IsMutableCanOnlyBeFlippedToFalseError());
createErrorFromNameLookup.set('IsMutableCanOnlyBeFlippedToFalse', () => new IsMutableCanOnlyBeFlippedToFalseError());
/**
 * CollectionCannotBeVerifiedInThisInstruction: 'Collection cannot be verified in this instruction'
 *
 * @category Errors
 * @category generated
 */
class CollectionCannotBeVerifiedInThisInstructionError extends Error {
    constructor() {
        super('Collection cannot be verified in this instruction');
        this.code = 0x4a;
        this.name = 'CollectionCannotBeVerifiedInThisInstruction';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionCannotBeVerifiedInThisInstructionError);
        }
    }
}
exports.CollectionCannotBeVerifiedInThisInstructionError = CollectionCannotBeVerifiedInThisInstructionError;
createErrorFromCodeLookup.set(0x4a, () => new CollectionCannotBeVerifiedInThisInstructionError());
createErrorFromNameLookup.set('CollectionCannotBeVerifiedInThisInstruction', () => new CollectionCannotBeVerifiedInThisInstructionError());
/**
 * Removed: 'This instruction was deprecated in a previous release and is now removed'
 *
 * @category Errors
 * @category generated
 */
class RemovedError extends Error {
    constructor() {
        super('This instruction was deprecated in a previous release and is now removed');
        this.code = 0x4b;
        this.name = 'Removed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, RemovedError);
        }
    }
}
exports.RemovedError = RemovedError;
createErrorFromCodeLookup.set(0x4b, () => new RemovedError());
createErrorFromNameLookup.set('Removed', () => new RemovedError());
/**
 * MustBeBurned: 'This token use method is burn and there are no remaining uses, it must be burned'
 *
 * @category Errors
 * @category generated
 */
class MustBeBurnedError extends Error {
    constructor() {
        super('This token use method is burn and there are no remaining uses, it must be burned');
        this.code = 0x4c;
        this.name = 'MustBeBurned';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MustBeBurnedError);
        }
    }
}
exports.MustBeBurnedError = MustBeBurnedError;
createErrorFromCodeLookup.set(0x4c, () => new MustBeBurnedError());
createErrorFromNameLookup.set('MustBeBurned', () => new MustBeBurnedError());
/**
 * InvalidUseMethod: 'This use method is invalid'
 *
 * @category Errors
 * @category generated
 */
class InvalidUseMethodError extends Error {
    constructor() {
        super('This use method is invalid');
        this.code = 0x4d;
        this.name = 'InvalidUseMethod';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidUseMethodError);
        }
    }
}
exports.InvalidUseMethodError = InvalidUseMethodError;
createErrorFromCodeLookup.set(0x4d, () => new InvalidUseMethodError());
createErrorFromNameLookup.set('InvalidUseMethod', () => new InvalidUseMethodError());
/**
 * CannotChangeUseMethodAfterFirstUse: 'Cannot Change Use Method after the first use'
 *
 * @category Errors
 * @category generated
 */
class CannotChangeUseMethodAfterFirstUseError extends Error {
    constructor() {
        super('Cannot Change Use Method after the first use');
        this.code = 0x4e;
        this.name = 'CannotChangeUseMethodAfterFirstUse';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotChangeUseMethodAfterFirstUseError);
        }
    }
}
exports.CannotChangeUseMethodAfterFirstUseError = CannotChangeUseMethodAfterFirstUseError;
createErrorFromCodeLookup.set(0x4e, () => new CannotChangeUseMethodAfterFirstUseError());
createErrorFromNameLookup.set('CannotChangeUseMethodAfterFirstUse', () => new CannotChangeUseMethodAfterFirstUseError());
/**
 * CannotChangeUsesAfterFirstUse: 'Cannot Change Remaining or Available uses after the first use'
 *
 * @category Errors
 * @category generated
 */
class CannotChangeUsesAfterFirstUseError extends Error {
    constructor() {
        super('Cannot Change Remaining or Available uses after the first use');
        this.code = 0x4f;
        this.name = 'CannotChangeUsesAfterFirstUse';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotChangeUsesAfterFirstUseError);
        }
    }
}
exports.CannotChangeUsesAfterFirstUseError = CannotChangeUsesAfterFirstUseError;
createErrorFromCodeLookup.set(0x4f, () => new CannotChangeUsesAfterFirstUseError());
createErrorFromNameLookup.set('CannotChangeUsesAfterFirstUse', () => new CannotChangeUsesAfterFirstUseError());
/**
 * CollectionNotFound: 'Collection Not Found on Metadata'
 *
 * @category Errors
 * @category generated
 */
class CollectionNotFoundError extends Error {
    constructor() {
        super('Collection Not Found on Metadata');
        this.code = 0x50;
        this.name = 'CollectionNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionNotFoundError);
        }
    }
}
exports.CollectionNotFoundError = CollectionNotFoundError;
createErrorFromCodeLookup.set(0x50, () => new CollectionNotFoundError());
createErrorFromNameLookup.set('CollectionNotFound', () => new CollectionNotFoundError());
/**
 * InvalidCollectionUpdateAuthority: 'Collection Update Authority is invalid'
 *
 * @category Errors
 * @category generated
 */
class InvalidCollectionUpdateAuthorityError extends Error {
    constructor() {
        super('Collection Update Authority is invalid');
        this.code = 0x51;
        this.name = 'InvalidCollectionUpdateAuthority';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidCollectionUpdateAuthorityError);
        }
    }
}
exports.InvalidCollectionUpdateAuthorityError = InvalidCollectionUpdateAuthorityError;
createErrorFromCodeLookup.set(0x51, () => new InvalidCollectionUpdateAuthorityError());
createErrorFromNameLookup.set('InvalidCollectionUpdateAuthority', () => new InvalidCollectionUpdateAuthorityError());
/**
 * CollectionMustBeAUniqueMasterEdition: 'Collection Must Be a Unique Master Edition v2'
 *
 * @category Errors
 * @category generated
 */
class CollectionMustBeAUniqueMasterEditionError extends Error {
    constructor() {
        super('Collection Must Be a Unique Master Edition v2');
        this.code = 0x52;
        this.name = 'CollectionMustBeAUniqueMasterEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionMustBeAUniqueMasterEditionError);
        }
    }
}
exports.CollectionMustBeAUniqueMasterEditionError = CollectionMustBeAUniqueMasterEditionError;
createErrorFromCodeLookup.set(0x52, () => new CollectionMustBeAUniqueMasterEditionError());
createErrorFromNameLookup.set('CollectionMustBeAUniqueMasterEdition', () => new CollectionMustBeAUniqueMasterEditionError());
/**
 * UseAuthorityRecordAlreadyExists: 'The Use Authority Record Already Exists, to modify it Revoke, then Approve'
 *
 * @category Errors
 * @category generated
 */
class UseAuthorityRecordAlreadyExistsError extends Error {
    constructor() {
        super('The Use Authority Record Already Exists, to modify it Revoke, then Approve');
        this.code = 0x53;
        this.name = 'UseAuthorityRecordAlreadyExists';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UseAuthorityRecordAlreadyExistsError);
        }
    }
}
exports.UseAuthorityRecordAlreadyExistsError = UseAuthorityRecordAlreadyExistsError;
createErrorFromCodeLookup.set(0x53, () => new UseAuthorityRecordAlreadyExistsError());
createErrorFromNameLookup.set('UseAuthorityRecordAlreadyExists', () => new UseAuthorityRecordAlreadyExistsError());
/**
 * UseAuthorityRecordAlreadyRevoked: 'The Use Authority Record is empty or already revoked'
 *
 * @category Errors
 * @category generated
 */
class UseAuthorityRecordAlreadyRevokedError extends Error {
    constructor() {
        super('The Use Authority Record is empty or already revoked');
        this.code = 0x54;
        this.name = 'UseAuthorityRecordAlreadyRevoked';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UseAuthorityRecordAlreadyRevokedError);
        }
    }
}
exports.UseAuthorityRecordAlreadyRevokedError = UseAuthorityRecordAlreadyRevokedError;
createErrorFromCodeLookup.set(0x54, () => new UseAuthorityRecordAlreadyRevokedError());
createErrorFromNameLookup.set('UseAuthorityRecordAlreadyRevoked', () => new UseAuthorityRecordAlreadyRevokedError());
/**
 * Unusable: 'This token has no uses'
 *
 * @category Errors
 * @category generated
 */
class UnusableError extends Error {
    constructor() {
        super('This token has no uses');
        this.code = 0x55;
        this.name = 'Unusable';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UnusableError);
        }
    }
}
exports.UnusableError = UnusableError;
createErrorFromCodeLookup.set(0x55, () => new UnusableError());
createErrorFromNameLookup.set('Unusable', () => new UnusableError());
/**
 * NotEnoughUses: 'There are not enough Uses left on this token.'
 *
 * @category Errors
 * @category generated
 */
class NotEnoughUsesError extends Error {
    constructor() {
        super('There are not enough Uses left on this token.');
        this.code = 0x56;
        this.name = 'NotEnoughUses';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotEnoughUsesError);
        }
    }
}
exports.NotEnoughUsesError = NotEnoughUsesError;
createErrorFromCodeLookup.set(0x56, () => new NotEnoughUsesError());
createErrorFromNameLookup.set('NotEnoughUses', () => new NotEnoughUsesError());
/**
 * CollectionAuthorityRecordAlreadyExists: 'This Collection Authority Record Already Exists.'
 *
 * @category Errors
 * @category generated
 */
class CollectionAuthorityRecordAlreadyExistsError extends Error {
    constructor() {
        super('This Collection Authority Record Already Exists.');
        this.code = 0x57;
        this.name = 'CollectionAuthorityRecordAlreadyExists';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionAuthorityRecordAlreadyExistsError);
        }
    }
}
exports.CollectionAuthorityRecordAlreadyExistsError = CollectionAuthorityRecordAlreadyExistsError;
createErrorFromCodeLookup.set(0x57, () => new CollectionAuthorityRecordAlreadyExistsError());
createErrorFromNameLookup.set('CollectionAuthorityRecordAlreadyExists', () => new CollectionAuthorityRecordAlreadyExistsError());
/**
 * CollectionAuthorityDoesNotExist: 'This Collection Authority Record Does Not Exist.'
 *
 * @category Errors
 * @category generated
 */
class CollectionAuthorityDoesNotExistError extends Error {
    constructor() {
        super('This Collection Authority Record Does Not Exist.');
        this.code = 0x58;
        this.name = 'CollectionAuthorityDoesNotExist';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionAuthorityDoesNotExistError);
        }
    }
}
exports.CollectionAuthorityDoesNotExistError = CollectionAuthorityDoesNotExistError;
createErrorFromCodeLookup.set(0x58, () => new CollectionAuthorityDoesNotExistError());
createErrorFromNameLookup.set('CollectionAuthorityDoesNotExist', () => new CollectionAuthorityDoesNotExistError());
/**
 * InvalidUseAuthorityRecord: 'This Use Authority Record is invalid.'
 *
 * @category Errors
 * @category generated
 */
class InvalidUseAuthorityRecordError extends Error {
    constructor() {
        super('This Use Authority Record is invalid.');
        this.code = 0x59;
        this.name = 'InvalidUseAuthorityRecord';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidUseAuthorityRecordError);
        }
    }
}
exports.InvalidUseAuthorityRecordError = InvalidUseAuthorityRecordError;
createErrorFromCodeLookup.set(0x59, () => new InvalidUseAuthorityRecordError());
createErrorFromNameLookup.set('InvalidUseAuthorityRecord', () => new InvalidUseAuthorityRecordError());
/**
 * InvalidCollectionAuthorityRecord: 'This Collection Authority Record is invalid.'
 *
 * @category Errors
 * @category generated
 */
class InvalidCollectionAuthorityRecordError extends Error {
    constructor() {
        super('This Collection Authority Record is invalid.');
        this.code = 0x5a;
        this.name = 'InvalidCollectionAuthorityRecord';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidCollectionAuthorityRecordError);
        }
    }
}
exports.InvalidCollectionAuthorityRecordError = InvalidCollectionAuthorityRecordError;
createErrorFromCodeLookup.set(0x5a, () => new InvalidCollectionAuthorityRecordError());
createErrorFromNameLookup.set('InvalidCollectionAuthorityRecord', () => new InvalidCollectionAuthorityRecordError());
/**
 * InvalidFreezeAuthority: 'Metadata does not match the freeze authority on the mint'
 *
 * @category Errors
 * @category generated
 */
class InvalidFreezeAuthorityError extends Error {
    constructor() {
        super('Metadata does not match the freeze authority on the mint');
        this.code = 0x5b;
        this.name = 'InvalidFreezeAuthority';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidFreezeAuthorityError);
        }
    }
}
exports.InvalidFreezeAuthorityError = InvalidFreezeAuthorityError;
createErrorFromCodeLookup.set(0x5b, () => new InvalidFreezeAuthorityError());
createErrorFromNameLookup.set('InvalidFreezeAuthority', () => new InvalidFreezeAuthorityError());
/**
 * InvalidDelegate: 'All tokens in this account have not been delegated to this user.'
 *
 * @category Errors
 * @category generated
 */
class InvalidDelegateError extends Error {
    constructor() {
        super('All tokens in this account have not been delegated to this user.');
        this.code = 0x5c;
        this.name = 'InvalidDelegate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidDelegateError);
        }
    }
}
exports.InvalidDelegateError = InvalidDelegateError;
createErrorFromCodeLookup.set(0x5c, () => new InvalidDelegateError());
createErrorFromNameLookup.set('InvalidDelegate', () => new InvalidDelegateError());
/**
 * CannotAdjustVerifiedCreator: 'Creator can not be adjusted once they are verified.'
 *
 * @category Errors
 * @category generated
 */
class CannotAdjustVerifiedCreatorError extends Error {
    constructor() {
        super('Creator can not be adjusted once they are verified.');
        this.code = 0x5d;
        this.name = 'CannotAdjustVerifiedCreator';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotAdjustVerifiedCreatorError);
        }
    }
}
exports.CannotAdjustVerifiedCreatorError = CannotAdjustVerifiedCreatorError;
createErrorFromCodeLookup.set(0x5d, () => new CannotAdjustVerifiedCreatorError());
createErrorFromNameLookup.set('CannotAdjustVerifiedCreator', () => new CannotAdjustVerifiedCreatorError());
/**
 * CannotRemoveVerifiedCreator: 'Verified creators cannot be removed.'
 *
 * @category Errors
 * @category generated
 */
class CannotRemoveVerifiedCreatorError extends Error {
    constructor() {
        super('Verified creators cannot be removed.');
        this.code = 0x5e;
        this.name = 'CannotRemoveVerifiedCreator';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotRemoveVerifiedCreatorError);
        }
    }
}
exports.CannotRemoveVerifiedCreatorError = CannotRemoveVerifiedCreatorError;
createErrorFromCodeLookup.set(0x5e, () => new CannotRemoveVerifiedCreatorError());
createErrorFromNameLookup.set('CannotRemoveVerifiedCreator', () => new CannotRemoveVerifiedCreatorError());
/**
 * CannotWipeVerifiedCreators: 'Can not wipe verified creators.'
 *
 * @category Errors
 * @category generated
 */
class CannotWipeVerifiedCreatorsError extends Error {
    constructor() {
        super('Can not wipe verified creators.');
        this.code = 0x5f;
        this.name = 'CannotWipeVerifiedCreators';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotWipeVerifiedCreatorsError);
        }
    }
}
exports.CannotWipeVerifiedCreatorsError = CannotWipeVerifiedCreatorsError;
createErrorFromCodeLookup.set(0x5f, () => new CannotWipeVerifiedCreatorsError());
createErrorFromNameLookup.set('CannotWipeVerifiedCreators', () => new CannotWipeVerifiedCreatorsError());
/**
 * NotAllowedToChangeSellerFeeBasisPoints: 'Not allowed to change seller fee basis points.'
 *
 * @category Errors
 * @category generated
 */
class NotAllowedToChangeSellerFeeBasisPointsError extends Error {
    constructor() {
        super('Not allowed to change seller fee basis points.');
        this.code = 0x60;
        this.name = 'NotAllowedToChangeSellerFeeBasisPoints';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotAllowedToChangeSellerFeeBasisPointsError);
        }
    }
}
exports.NotAllowedToChangeSellerFeeBasisPointsError = NotAllowedToChangeSellerFeeBasisPointsError;
createErrorFromCodeLookup.set(0x60, () => new NotAllowedToChangeSellerFeeBasisPointsError());
createErrorFromNameLookup.set('NotAllowedToChangeSellerFeeBasisPoints', () => new NotAllowedToChangeSellerFeeBasisPointsError());
/**
 * EditionOverrideCannotBeZero: 'Edition override cannot be zero'
 *
 * @category Errors
 * @category generated
 */
class EditionOverrideCannotBeZeroError extends Error {
    constructor() {
        super('Edition override cannot be zero');
        this.code = 0x61;
        this.name = 'EditionOverrideCannotBeZero';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, EditionOverrideCannotBeZeroError);
        }
    }
}
exports.EditionOverrideCannotBeZeroError = EditionOverrideCannotBeZeroError;
createErrorFromCodeLookup.set(0x61, () => new EditionOverrideCannotBeZeroError());
createErrorFromNameLookup.set('EditionOverrideCannotBeZero', () => new EditionOverrideCannotBeZeroError());
/**
 * InvalidUser: 'Invalid User'
 *
 * @category Errors
 * @category generated
 */
class InvalidUserError extends Error {
    constructor() {
        super('Invalid User');
        this.code = 0x62;
        this.name = 'InvalidUser';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidUserError);
        }
    }
}
exports.InvalidUserError = InvalidUserError;
createErrorFromCodeLookup.set(0x62, () => new InvalidUserError());
createErrorFromNameLookup.set('InvalidUser', () => new InvalidUserError());
/**
 * RevokeCollectionAuthoritySignerIncorrect: 'Revoke Collection Authority signer is incorrect'
 *
 * @category Errors
 * @category generated
 */
class RevokeCollectionAuthoritySignerIncorrectError extends Error {
    constructor() {
        super('Revoke Collection Authority signer is incorrect');
        this.code = 0x63;
        this.name = 'RevokeCollectionAuthoritySignerIncorrect';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, RevokeCollectionAuthoritySignerIncorrectError);
        }
    }
}
exports.RevokeCollectionAuthoritySignerIncorrectError = RevokeCollectionAuthoritySignerIncorrectError;
createErrorFromCodeLookup.set(0x63, () => new RevokeCollectionAuthoritySignerIncorrectError());
createErrorFromNameLookup.set('RevokeCollectionAuthoritySignerIncorrect', () => new RevokeCollectionAuthoritySignerIncorrectError());
/**
 * TokenCloseFailed: 'Token close failed'
 *
 * @category Errors
 * @category generated
 */
class TokenCloseFailedError extends Error {
    constructor() {
        super('Token close failed');
        this.code = 0x64;
        this.name = 'TokenCloseFailed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenCloseFailedError);
        }
    }
}
exports.TokenCloseFailedError = TokenCloseFailedError;
createErrorFromCodeLookup.set(0x64, () => new TokenCloseFailedError());
createErrorFromNameLookup.set('TokenCloseFailed', () => new TokenCloseFailedError());
/**
 * UnsizedCollection: 'Can't use this function on unsized collection'
 *
 * @category Errors
 * @category generated
 */
class UnsizedCollectionError extends Error {
    constructor() {
        super("Can't use this function on unsized collection");
        this.code = 0x65;
        this.name = 'UnsizedCollection';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UnsizedCollectionError);
        }
    }
}
exports.UnsizedCollectionError = UnsizedCollectionError;
createErrorFromCodeLookup.set(0x65, () => new UnsizedCollectionError());
createErrorFromNameLookup.set('UnsizedCollection', () => new UnsizedCollectionError());
/**
 * SizedCollection: 'Can't use this function on a sized collection'
 *
 * @category Errors
 * @category generated
 */
class SizedCollectionError extends Error {
    constructor() {
        super("Can't use this function on a sized collection");
        this.code = 0x66;
        this.name = 'SizedCollection';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SizedCollectionError);
        }
    }
}
exports.SizedCollectionError = SizedCollectionError;
createErrorFromCodeLookup.set(0x66, () => new SizedCollectionError());
createErrorFromNameLookup.set('SizedCollection', () => new SizedCollectionError());
/**
 * MissingCollectionMetadata: 'Missing collection metadata account'
 *
 * @category Errors
 * @category generated
 */
class MissingCollectionMetadataError extends Error {
    constructor() {
        super('Missing collection metadata account');
        this.code = 0x67;
        this.name = 'MissingCollectionMetadata';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingCollectionMetadataError);
        }
    }
}
exports.MissingCollectionMetadataError = MissingCollectionMetadataError;
createErrorFromCodeLookup.set(0x67, () => new MissingCollectionMetadataError());
createErrorFromNameLookup.set('MissingCollectionMetadata', () => new MissingCollectionMetadataError());
/**
 * NotAMemberOfCollection: 'This NFT is not a member of the specified collection.'
 *
 * @category Errors
 * @category generated
 */
class NotAMemberOfCollectionError extends Error {
    constructor() {
        super('This NFT is not a member of the specified collection.');
        this.code = 0x68;
        this.name = 'NotAMemberOfCollection';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotAMemberOfCollectionError);
        }
    }
}
exports.NotAMemberOfCollectionError = NotAMemberOfCollectionError;
createErrorFromCodeLookup.set(0x68, () => new NotAMemberOfCollectionError());
createErrorFromNameLookup.set('NotAMemberOfCollection', () => new NotAMemberOfCollectionError());
/**
 * NotVerifiedMemberOfCollection: 'This NFT is not a verified member of the specified collection.'
 *
 * @category Errors
 * @category generated
 */
class NotVerifiedMemberOfCollectionError extends Error {
    constructor() {
        super('This NFT is not a verified member of the specified collection.');
        this.code = 0x69;
        this.name = 'NotVerifiedMemberOfCollection';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotVerifiedMemberOfCollectionError);
        }
    }
}
exports.NotVerifiedMemberOfCollectionError = NotVerifiedMemberOfCollectionError;
createErrorFromCodeLookup.set(0x69, () => new NotVerifiedMemberOfCollectionError());
createErrorFromNameLookup.set('NotVerifiedMemberOfCollection', () => new NotVerifiedMemberOfCollectionError());
/**
 * NotACollectionParent: 'This NFT is not a collection parent NFT.'
 *
 * @category Errors
 * @category generated
 */
class NotACollectionParentError extends Error {
    constructor() {
        super('This NFT is not a collection parent NFT.');
        this.code = 0x6a;
        this.name = 'NotACollectionParent';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotACollectionParentError);
        }
    }
}
exports.NotACollectionParentError = NotACollectionParentError;
createErrorFromCodeLookup.set(0x6a, () => new NotACollectionParentError());
createErrorFromNameLookup.set('NotACollectionParent', () => new NotACollectionParentError());
/**
 * CouldNotDetermineTokenStandard: 'Could not determine a TokenStandard type.'
 *
 * @category Errors
 * @category generated
 */
class CouldNotDetermineTokenStandardError extends Error {
    constructor() {
        super('Could not determine a TokenStandard type.');
        this.code = 0x6b;
        this.name = 'CouldNotDetermineTokenStandard';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CouldNotDetermineTokenStandardError);
        }
    }
}
exports.CouldNotDetermineTokenStandardError = CouldNotDetermineTokenStandardError;
createErrorFromCodeLookup.set(0x6b, () => new CouldNotDetermineTokenStandardError());
createErrorFromNameLookup.set('CouldNotDetermineTokenStandard', () => new CouldNotDetermineTokenStandardError());
/**
 * MissingEditionAccount: 'This mint account has an edition but none was provided.'
 *
 * @category Errors
 * @category generated
 */
class MissingEditionAccountError extends Error {
    constructor() {
        super('This mint account has an edition but none was provided.');
        this.code = 0x6c;
        this.name = 'MissingEditionAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingEditionAccountError);
        }
    }
}
exports.MissingEditionAccountError = MissingEditionAccountError;
createErrorFromCodeLookup.set(0x6c, () => new MissingEditionAccountError());
createErrorFromNameLookup.set('MissingEditionAccount', () => new MissingEditionAccountError());
/**
 * NotAMasterEdition: 'This edition is not a Master Edition'
 *
 * @category Errors
 * @category generated
 */
class NotAMasterEditionError extends Error {
    constructor() {
        super('This edition is not a Master Edition');
        this.code = 0x6d;
        this.name = 'NotAMasterEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotAMasterEditionError);
        }
    }
}
exports.NotAMasterEditionError = NotAMasterEditionError;
createErrorFromCodeLookup.set(0x6d, () => new NotAMasterEditionError());
createErrorFromNameLookup.set('NotAMasterEdition', () => new NotAMasterEditionError());
/**
 * MasterEditionHasPrints: 'This Master Edition has existing prints'
 *
 * @category Errors
 * @category generated
 */
class MasterEditionHasPrintsError extends Error {
    constructor() {
        super('This Master Edition has existing prints');
        this.code = 0x6e;
        this.name = 'MasterEditionHasPrints';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MasterEditionHasPrintsError);
        }
    }
}
exports.MasterEditionHasPrintsError = MasterEditionHasPrintsError;
createErrorFromCodeLookup.set(0x6e, () => new MasterEditionHasPrintsError());
createErrorFromNameLookup.set('MasterEditionHasPrints', () => new MasterEditionHasPrintsError());
/**
 * BorshDeserializationError: 'Borsh Deserialization Error'
 *
 * @category Errors
 * @category generated
 */
class BorshDeserializationErrorError extends Error {
    constructor() {
        super('Borsh Deserialization Error');
        this.code = 0x6f;
        this.name = 'BorshDeserializationError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, BorshDeserializationErrorError);
        }
    }
}
exports.BorshDeserializationErrorError = BorshDeserializationErrorError;
createErrorFromCodeLookup.set(0x6f, () => new BorshDeserializationErrorError());
createErrorFromNameLookup.set('BorshDeserializationError', () => new BorshDeserializationErrorError());
/**
 * CannotUpdateVerifiedCollection: 'Cannot update a verified collection in this command'
 *
 * @category Errors
 * @category generated
 */
class CannotUpdateVerifiedCollectionError extends Error {
    constructor() {
        super('Cannot update a verified collection in this command');
        this.code = 0x70;
        this.name = 'CannotUpdateVerifiedCollection';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotUpdateVerifiedCollectionError);
        }
    }
}
exports.CannotUpdateVerifiedCollectionError = CannotUpdateVerifiedCollectionError;
createErrorFromCodeLookup.set(0x70, () => new CannotUpdateVerifiedCollectionError());
createErrorFromNameLookup.set('CannotUpdateVerifiedCollection', () => new CannotUpdateVerifiedCollectionError());
/**
 * CollectionMasterEditionAccountInvalid: 'Edition account doesnt match collection '
 *
 * @category Errors
 * @category generated
 */
class CollectionMasterEditionAccountInvalidError extends Error {
    constructor() {
        super('Edition account doesnt match collection ');
        this.code = 0x71;
        this.name = 'CollectionMasterEditionAccountInvalid';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionMasterEditionAccountInvalidError);
        }
    }
}
exports.CollectionMasterEditionAccountInvalidError = CollectionMasterEditionAccountInvalidError;
createErrorFromCodeLookup.set(0x71, () => new CollectionMasterEditionAccountInvalidError());
createErrorFromNameLookup.set('CollectionMasterEditionAccountInvalid', () => new CollectionMasterEditionAccountInvalidError());
/**
 * AlreadyVerified: 'Item is already verified.'
 *
 * @category Errors
 * @category generated
 */
class AlreadyVerifiedError extends Error {
    constructor() {
        super('Item is already verified.');
        this.code = 0x72;
        this.name = 'AlreadyVerified';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AlreadyVerifiedError);
        }
    }
}
exports.AlreadyVerifiedError = AlreadyVerifiedError;
createErrorFromCodeLookup.set(0x72, () => new AlreadyVerifiedError());
createErrorFromNameLookup.set('AlreadyVerified', () => new AlreadyVerifiedError());
/**
 * AlreadyUnverified: 'Item is already unverified.'
 *
 * @category Errors
 * @category generated
 */
class AlreadyUnverifiedError extends Error {
    constructor() {
        super('Item is already unverified.');
        this.code = 0x73;
        this.name = 'AlreadyUnverified';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AlreadyUnverifiedError);
        }
    }
}
exports.AlreadyUnverifiedError = AlreadyUnverifiedError;
createErrorFromCodeLookup.set(0x73, () => new AlreadyUnverifiedError());
createErrorFromNameLookup.set('AlreadyUnverified', () => new AlreadyUnverifiedError());
/**
 * NotAPrintEdition: 'This edition is not a Print Edition'
 *
 * @category Errors
 * @category generated
 */
class NotAPrintEditionError extends Error {
    constructor() {
        super('This edition is not a Print Edition');
        this.code = 0x74;
        this.name = 'NotAPrintEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotAPrintEditionError);
        }
    }
}
exports.NotAPrintEditionError = NotAPrintEditionError;
createErrorFromCodeLookup.set(0x74, () => new NotAPrintEditionError());
createErrorFromNameLookup.set('NotAPrintEdition', () => new NotAPrintEditionError());
/**
 * InvalidMasterEdition: 'Invalid Master Edition'
 *
 * @category Errors
 * @category generated
 */
class InvalidMasterEditionError extends Error {
    constructor() {
        super('Invalid Master Edition');
        this.code = 0x75;
        this.name = 'InvalidMasterEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidMasterEditionError);
        }
    }
}
exports.InvalidMasterEditionError = InvalidMasterEditionError;
createErrorFromCodeLookup.set(0x75, () => new InvalidMasterEditionError());
createErrorFromNameLookup.set('InvalidMasterEdition', () => new InvalidMasterEditionError());
/**
 * InvalidPrintEdition: 'Invalid Print Edition'
 *
 * @category Errors
 * @category generated
 */
class InvalidPrintEditionError extends Error {
    constructor() {
        super('Invalid Print Edition');
        this.code = 0x76;
        this.name = 'InvalidPrintEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidPrintEditionError);
        }
    }
}
exports.InvalidPrintEditionError = InvalidPrintEditionError;
createErrorFromCodeLookup.set(0x76, () => new InvalidPrintEditionError());
createErrorFromNameLookup.set('InvalidPrintEdition', () => new InvalidPrintEditionError());
/**
 * InvalidEditionMarker: 'Invalid Edition Marker'
 *
 * @category Errors
 * @category generated
 */
class InvalidEditionMarkerError extends Error {
    constructor() {
        super('Invalid Edition Marker');
        this.code = 0x77;
        this.name = 'InvalidEditionMarker';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidEditionMarkerError);
        }
    }
}
exports.InvalidEditionMarkerError = InvalidEditionMarkerError;
createErrorFromCodeLookup.set(0x77, () => new InvalidEditionMarkerError());
createErrorFromNameLookup.set('InvalidEditionMarker', () => new InvalidEditionMarkerError());
/**
 * ReservationListDeprecated: 'Reservation List is Deprecated'
 *
 * @category Errors
 * @category generated
 */
class ReservationListDeprecatedError extends Error {
    constructor() {
        super('Reservation List is Deprecated');
        this.code = 0x78;
        this.name = 'ReservationListDeprecated';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReservationListDeprecatedError);
        }
    }
}
exports.ReservationListDeprecatedError = ReservationListDeprecatedError;
createErrorFromCodeLookup.set(0x78, () => new ReservationListDeprecatedError());
createErrorFromNameLookup.set('ReservationListDeprecated', () => new ReservationListDeprecatedError());
/**
 * PrintEditionDoesNotMatchMasterEdition: 'Print Edition does not match Master Edition'
 *
 * @category Errors
 * @category generated
 */
class PrintEditionDoesNotMatchMasterEditionError extends Error {
    constructor() {
        super('Print Edition does not match Master Edition');
        this.code = 0x79;
        this.name = 'PrintEditionDoesNotMatchMasterEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PrintEditionDoesNotMatchMasterEditionError);
        }
    }
}
exports.PrintEditionDoesNotMatchMasterEditionError = PrintEditionDoesNotMatchMasterEditionError;
createErrorFromCodeLookup.set(0x79, () => new PrintEditionDoesNotMatchMasterEditionError());
createErrorFromNameLookup.set('PrintEditionDoesNotMatchMasterEdition', () => new PrintEditionDoesNotMatchMasterEditionError());
/**
 * EditionNumberGreaterThanMaxSupply: 'Edition Number greater than max supply'
 *
 * @category Errors
 * @category generated
 */
class EditionNumberGreaterThanMaxSupplyError extends Error {
    constructor() {
        super('Edition Number greater than max supply');
        this.code = 0x7a;
        this.name = 'EditionNumberGreaterThanMaxSupply';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, EditionNumberGreaterThanMaxSupplyError);
        }
    }
}
exports.EditionNumberGreaterThanMaxSupplyError = EditionNumberGreaterThanMaxSupplyError;
createErrorFromCodeLookup.set(0x7a, () => new EditionNumberGreaterThanMaxSupplyError());
createErrorFromNameLookup.set('EditionNumberGreaterThanMaxSupply', () => new EditionNumberGreaterThanMaxSupplyError());
/**
 * MustUnverify: 'Must unverify before migrating collections.'
 *
 * @category Errors
 * @category generated
 */
class MustUnverifyError extends Error {
    constructor() {
        super('Must unverify before migrating collections.');
        this.code = 0x7b;
        this.name = 'MustUnverify';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MustUnverifyError);
        }
    }
}
exports.MustUnverifyError = MustUnverifyError;
createErrorFromCodeLookup.set(0x7b, () => new MustUnverifyError());
createErrorFromNameLookup.set('MustUnverify', () => new MustUnverifyError());
/**
 * InvalidEscrowBumpSeed: 'Invalid Escrow Account Bump Seed'
 *
 * @category Errors
 * @category generated
 */
class InvalidEscrowBumpSeedError extends Error {
    constructor() {
        super('Invalid Escrow Account Bump Seed');
        this.code = 0x7c;
        this.name = 'InvalidEscrowBumpSeed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidEscrowBumpSeedError);
        }
    }
}
exports.InvalidEscrowBumpSeedError = InvalidEscrowBumpSeedError;
createErrorFromCodeLookup.set(0x7c, () => new InvalidEscrowBumpSeedError());
createErrorFromNameLookup.set('InvalidEscrowBumpSeed', () => new InvalidEscrowBumpSeedError());
/**
 * MustBeEscrowAuthority: 'Must Escrow Authority'
 *
 * @category Errors
 * @category generated
 */
class MustBeEscrowAuthorityError extends Error {
    constructor() {
        super('Must Escrow Authority');
        this.code = 0x7d;
        this.name = 'MustBeEscrowAuthority';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MustBeEscrowAuthorityError);
        }
    }
}
exports.MustBeEscrowAuthorityError = MustBeEscrowAuthorityError;
createErrorFromCodeLookup.set(0x7d, () => new MustBeEscrowAuthorityError());
createErrorFromNameLookup.set('MustBeEscrowAuthority', () => new MustBeEscrowAuthorityError());
/**
 * InvalidSystemProgram: 'Invalid System Program'
 *
 * @category Errors
 * @category generated
 */
class InvalidSystemProgramError extends Error {
    constructor() {
        super('Invalid System Program');
        this.code = 0x7e;
        this.name = 'InvalidSystemProgram';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidSystemProgramError);
        }
    }
}
exports.InvalidSystemProgramError = InvalidSystemProgramError;
createErrorFromCodeLookup.set(0x7e, () => new InvalidSystemProgramError());
createErrorFromNameLookup.set('InvalidSystemProgram', () => new InvalidSystemProgramError());
/**
 * MustBeNonFungible: 'Must be a Non Fungible Token'
 *
 * @category Errors
 * @category generated
 */
class MustBeNonFungibleError extends Error {
    constructor() {
        super('Must be a Non Fungible Token');
        this.code = 0x7f;
        this.name = 'MustBeNonFungible';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MustBeNonFungibleError);
        }
    }
}
exports.MustBeNonFungibleError = MustBeNonFungibleError;
createErrorFromCodeLookup.set(0x7f, () => new MustBeNonFungibleError());
createErrorFromNameLookup.set('MustBeNonFungible', () => new MustBeNonFungibleError());
/**
 * InsufficientTokens: 'Insufficient tokens for transfer'
 *
 * @category Errors
 * @category generated
 */
class InsufficientTokensError extends Error {
    constructor() {
        super('Insufficient tokens for transfer');
        this.code = 0x80;
        this.name = 'InsufficientTokens';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InsufficientTokensError);
        }
    }
}
exports.InsufficientTokensError = InsufficientTokensError;
createErrorFromCodeLookup.set(0x80, () => new InsufficientTokensError());
createErrorFromNameLookup.set('InsufficientTokens', () => new InsufficientTokensError());
/**
 * BorshSerializationError: 'Borsh Serialization Error'
 *
 * @category Errors
 * @category generated
 */
class BorshSerializationErrorError extends Error {
    constructor() {
        super('Borsh Serialization Error');
        this.code = 0x81;
        this.name = 'BorshSerializationError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, BorshSerializationErrorError);
        }
    }
}
exports.BorshSerializationErrorError = BorshSerializationErrorError;
createErrorFromCodeLookup.set(0x81, () => new BorshSerializationErrorError());
createErrorFromNameLookup.set('BorshSerializationError', () => new BorshSerializationErrorError());
/**
 * NoFreezeAuthoritySet: 'Cannot create NFT with no Freeze Authority.'
 *
 * @category Errors
 * @category generated
 */
class NoFreezeAuthoritySetError extends Error {
    constructor() {
        super('Cannot create NFT with no Freeze Authority.');
        this.code = 0x82;
        this.name = 'NoFreezeAuthoritySet';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NoFreezeAuthoritySetError);
        }
    }
}
exports.NoFreezeAuthoritySetError = NoFreezeAuthoritySetError;
createErrorFromCodeLookup.set(0x82, () => new NoFreezeAuthoritySetError());
createErrorFromNameLookup.set('NoFreezeAuthoritySet', () => new NoFreezeAuthoritySetError());
/**
 * InvalidCollectionSizeChange: 'Invalid collection size change'
 *
 * @category Errors
 * @category generated
 */
class InvalidCollectionSizeChangeError extends Error {
    constructor() {
        super('Invalid collection size change');
        this.code = 0x83;
        this.name = 'InvalidCollectionSizeChange';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidCollectionSizeChangeError);
        }
    }
}
exports.InvalidCollectionSizeChangeError = InvalidCollectionSizeChangeError;
createErrorFromCodeLookup.set(0x83, () => new InvalidCollectionSizeChangeError());
createErrorFromNameLookup.set('InvalidCollectionSizeChange', () => new InvalidCollectionSizeChangeError());
/**
 * InvalidBubblegumSigner: 'Invalid bubblegum signer'
 *
 * @category Errors
 * @category generated
 */
class InvalidBubblegumSignerError extends Error {
    constructor() {
        super('Invalid bubblegum signer');
        this.code = 0x84;
        this.name = 'InvalidBubblegumSigner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidBubblegumSignerError);
        }
    }
}
exports.InvalidBubblegumSignerError = InvalidBubblegumSignerError;
createErrorFromCodeLookup.set(0x84, () => new InvalidBubblegumSignerError());
createErrorFromNameLookup.set('InvalidBubblegumSigner', () => new InvalidBubblegumSignerError());
/**
 * EscrowParentHasDelegate: 'Escrow parent cannot have a delegate'
 *
 * @category Errors
 * @category generated
 */
class EscrowParentHasDelegateError extends Error {
    constructor() {
        super('Escrow parent cannot have a delegate');
        this.code = 0x85;
        this.name = 'EscrowParentHasDelegate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, EscrowParentHasDelegateError);
        }
    }
}
exports.EscrowParentHasDelegateError = EscrowParentHasDelegateError;
createErrorFromCodeLookup.set(0x85, () => new EscrowParentHasDelegateError());
createErrorFromNameLookup.set('EscrowParentHasDelegate', () => new EscrowParentHasDelegateError());
/**
 * MintIsNotSigner: 'Mint needs to be signer to initialize the account'
 *
 * @category Errors
 * @category generated
 */
class MintIsNotSignerError extends Error {
    constructor() {
        super('Mint needs to be signer to initialize the account');
        this.code = 0x86;
        this.name = 'MintIsNotSigner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MintIsNotSignerError);
        }
    }
}
exports.MintIsNotSignerError = MintIsNotSignerError;
createErrorFromCodeLookup.set(0x86, () => new MintIsNotSignerError());
createErrorFromNameLookup.set('MintIsNotSigner', () => new MintIsNotSignerError());
/**
 * InvalidTokenStandard: 'Invalid token standard'
 *
 * @category Errors
 * @category generated
 */
class InvalidTokenStandardError extends Error {
    constructor() {
        super('Invalid token standard');
        this.code = 0x87;
        this.name = 'InvalidTokenStandard';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidTokenStandardError);
        }
    }
}
exports.InvalidTokenStandardError = InvalidTokenStandardError;
createErrorFromCodeLookup.set(0x87, () => new InvalidTokenStandardError());
createErrorFromNameLookup.set('InvalidTokenStandard', () => new InvalidTokenStandardError());
/**
 * InvalidMintForTokenStandard: 'Invalid mint account for specified token standard'
 *
 * @category Errors
 * @category generated
 */
class InvalidMintForTokenStandardError extends Error {
    constructor() {
        super('Invalid mint account for specified token standard');
        this.code = 0x88;
        this.name = 'InvalidMintForTokenStandard';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidMintForTokenStandardError);
        }
    }
}
exports.InvalidMintForTokenStandardError = InvalidMintForTokenStandardError;
createErrorFromCodeLookup.set(0x88, () => new InvalidMintForTokenStandardError());
createErrorFromNameLookup.set('InvalidMintForTokenStandard', () => new InvalidMintForTokenStandardError());
/**
 * InvalidAuthorizationRules: 'Invalid authorization rules account'
 *
 * @category Errors
 * @category generated
 */
class InvalidAuthorizationRulesError extends Error {
    constructor() {
        super('Invalid authorization rules account');
        this.code = 0x89;
        this.name = 'InvalidAuthorizationRules';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidAuthorizationRulesError);
        }
    }
}
exports.InvalidAuthorizationRulesError = InvalidAuthorizationRulesError;
createErrorFromCodeLookup.set(0x89, () => new InvalidAuthorizationRulesError());
createErrorFromNameLookup.set('InvalidAuthorizationRules', () => new InvalidAuthorizationRulesError());
/**
 * MissingAuthorizationRules: 'Missing authorization rules account'
 *
 * @category Errors
 * @category generated
 */
class MissingAuthorizationRulesError extends Error {
    constructor() {
        super('Missing authorization rules account');
        this.code = 0x8a;
        this.name = 'MissingAuthorizationRules';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingAuthorizationRulesError);
        }
    }
}
exports.MissingAuthorizationRulesError = MissingAuthorizationRulesError;
createErrorFromCodeLookup.set(0x8a, () => new MissingAuthorizationRulesError());
createErrorFromNameLookup.set('MissingAuthorizationRules', () => new MissingAuthorizationRulesError());
/**
 * MissingProgrammableConfig: 'Missing programmable configuration'
 *
 * @category Errors
 * @category generated
 */
class MissingProgrammableConfigError extends Error {
    constructor() {
        super('Missing programmable configuration');
        this.code = 0x8b;
        this.name = 'MissingProgrammableConfig';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingProgrammableConfigError);
        }
    }
}
exports.MissingProgrammableConfigError = MissingProgrammableConfigError;
createErrorFromCodeLookup.set(0x8b, () => new MissingProgrammableConfigError());
createErrorFromNameLookup.set('MissingProgrammableConfig', () => new MissingProgrammableConfigError());
/**
 * InvalidProgrammableConfig: 'Invalid programmable configuration'
 *
 * @category Errors
 * @category generated
 */
class InvalidProgrammableConfigError extends Error {
    constructor() {
        super('Invalid programmable configuration');
        this.code = 0x8c;
        this.name = 'InvalidProgrammableConfig';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidProgrammableConfigError);
        }
    }
}
exports.InvalidProgrammableConfigError = InvalidProgrammableConfigError;
createErrorFromCodeLookup.set(0x8c, () => new InvalidProgrammableConfigError());
createErrorFromNameLookup.set('InvalidProgrammableConfig', () => new InvalidProgrammableConfigError());
/**
 * DelegateAlreadyExists: 'Delegate already exists'
 *
 * @category Errors
 * @category generated
 */
class DelegateAlreadyExistsError extends Error {
    constructor() {
        super('Delegate already exists');
        this.code = 0x8d;
        this.name = 'DelegateAlreadyExists';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DelegateAlreadyExistsError);
        }
    }
}
exports.DelegateAlreadyExistsError = DelegateAlreadyExistsError;
createErrorFromCodeLookup.set(0x8d, () => new DelegateAlreadyExistsError());
createErrorFromNameLookup.set('DelegateAlreadyExists', () => new DelegateAlreadyExistsError());
/**
 * DelegateNotFound: 'Delegate not found'
 *
 * @category Errors
 * @category generated
 */
class DelegateNotFoundError extends Error {
    constructor() {
        super('Delegate not found');
        this.code = 0x8e;
        this.name = 'DelegateNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DelegateNotFoundError);
        }
    }
}
exports.DelegateNotFoundError = DelegateNotFoundError;
createErrorFromCodeLookup.set(0x8e, () => new DelegateNotFoundError());
createErrorFromNameLookup.set('DelegateNotFound', () => new DelegateNotFoundError());
/**
 * MissingAccountInBuilder: 'Required account not set in instruction builder'
 *
 * @category Errors
 * @category generated
 */
class MissingAccountInBuilderError extends Error {
    constructor() {
        super('Required account not set in instruction builder');
        this.code = 0x8f;
        this.name = 'MissingAccountInBuilder';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingAccountInBuilderError);
        }
    }
}
exports.MissingAccountInBuilderError = MissingAccountInBuilderError;
createErrorFromCodeLookup.set(0x8f, () => new MissingAccountInBuilderError());
createErrorFromNameLookup.set('MissingAccountInBuilder', () => new MissingAccountInBuilderError());
/**
 * MissingArgumentInBuilder: 'Required argument not set in instruction builder'
 *
 * @category Errors
 * @category generated
 */
class MissingArgumentInBuilderError extends Error {
    constructor() {
        super('Required argument not set in instruction builder');
        this.code = 0x90;
        this.name = 'MissingArgumentInBuilder';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingArgumentInBuilderError);
        }
    }
}
exports.MissingArgumentInBuilderError = MissingArgumentInBuilderError;
createErrorFromCodeLookup.set(0x90, () => new MissingArgumentInBuilderError());
createErrorFromNameLookup.set('MissingArgumentInBuilder', () => new MissingArgumentInBuilderError());
/**
 * FeatureNotSupported: 'Feature not supported currently'
 *
 * @category Errors
 * @category generated
 */
class FeatureNotSupportedError extends Error {
    constructor() {
        super('Feature not supported currently');
        this.code = 0x91;
        this.name = 'FeatureNotSupported';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, FeatureNotSupportedError);
        }
    }
}
exports.FeatureNotSupportedError = FeatureNotSupportedError;
createErrorFromCodeLookup.set(0x91, () => new FeatureNotSupportedError());
createErrorFromNameLookup.set('FeatureNotSupported', () => new FeatureNotSupportedError());
/**
 * InvalidSystemWallet: 'Invalid system wallet'
 *
 * @category Errors
 * @category generated
 */
class InvalidSystemWalletError extends Error {
    constructor() {
        super('Invalid system wallet');
        this.code = 0x92;
        this.name = 'InvalidSystemWallet';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidSystemWalletError);
        }
    }
}
exports.InvalidSystemWalletError = InvalidSystemWalletError;
createErrorFromCodeLookup.set(0x92, () => new InvalidSystemWalletError());
createErrorFromNameLookup.set('InvalidSystemWallet', () => new InvalidSystemWalletError());
/**
 * OnlySaleDelegateCanTransfer: 'Only the sale delegate can transfer while its set'
 *
 * @category Errors
 * @category generated
 */
class OnlySaleDelegateCanTransferError extends Error {
    constructor() {
        super('Only the sale delegate can transfer while its set');
        this.code = 0x93;
        this.name = 'OnlySaleDelegateCanTransfer';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, OnlySaleDelegateCanTransferError);
        }
    }
}
exports.OnlySaleDelegateCanTransferError = OnlySaleDelegateCanTransferError;
createErrorFromCodeLookup.set(0x93, () => new OnlySaleDelegateCanTransferError());
createErrorFromNameLookup.set('OnlySaleDelegateCanTransfer', () => new OnlySaleDelegateCanTransferError());
/**
 * MissingTokenAccount: 'Missing token account'
 *
 * @category Errors
 * @category generated
 */
class MissingTokenAccountError extends Error {
    constructor() {
        super('Missing token account');
        this.code = 0x94;
        this.name = 'MissingTokenAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingTokenAccountError);
        }
    }
}
exports.MissingTokenAccountError = MissingTokenAccountError;
createErrorFromCodeLookup.set(0x94, () => new MissingTokenAccountError());
createErrorFromNameLookup.set('MissingTokenAccount', () => new MissingTokenAccountError());
/**
 * MissingSplTokenProgram: 'Missing SPL token program'
 *
 * @category Errors
 * @category generated
 */
class MissingSplTokenProgramError extends Error {
    constructor() {
        super('Missing SPL token program');
        this.code = 0x95;
        this.name = 'MissingSplTokenProgram';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingSplTokenProgramError);
        }
    }
}
exports.MissingSplTokenProgramError = MissingSplTokenProgramError;
createErrorFromCodeLookup.set(0x95, () => new MissingSplTokenProgramError());
createErrorFromNameLookup.set('MissingSplTokenProgram', () => new MissingSplTokenProgramError());
/**
 * MissingAuthorizationRulesProgram: 'Missing authorization rules program'
 *
 * @category Errors
 * @category generated
 */
class MissingAuthorizationRulesProgramError extends Error {
    constructor() {
        super('Missing authorization rules program');
        this.code = 0x96;
        this.name = 'MissingAuthorizationRulesProgram';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingAuthorizationRulesProgramError);
        }
    }
}
exports.MissingAuthorizationRulesProgramError = MissingAuthorizationRulesProgramError;
createErrorFromCodeLookup.set(0x96, () => new MissingAuthorizationRulesProgramError());
createErrorFromNameLookup.set('MissingAuthorizationRulesProgram', () => new MissingAuthorizationRulesProgramError());
/**
 * InvalidDelegateRoleForTransfer: 'Invalid delegate role for transfer'
 *
 * @category Errors
 * @category generated
 */
class InvalidDelegateRoleForTransferError extends Error {
    constructor() {
        super('Invalid delegate role for transfer');
        this.code = 0x97;
        this.name = 'InvalidDelegateRoleForTransfer';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidDelegateRoleForTransferError);
        }
    }
}
exports.InvalidDelegateRoleForTransferError = InvalidDelegateRoleForTransferError;
createErrorFromCodeLookup.set(0x97, () => new InvalidDelegateRoleForTransferError());
createErrorFromNameLookup.set('InvalidDelegateRoleForTransfer', () => new InvalidDelegateRoleForTransferError());
/**
 * InvalidTransferAuthority: 'Invalid transfer authority'
 *
 * @category Errors
 * @category generated
 */
class InvalidTransferAuthorityError extends Error {
    constructor() {
        super('Invalid transfer authority');
        this.code = 0x98;
        this.name = 'InvalidTransferAuthority';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidTransferAuthorityError);
        }
    }
}
exports.InvalidTransferAuthorityError = InvalidTransferAuthorityError;
createErrorFromCodeLookup.set(0x98, () => new InvalidTransferAuthorityError());
createErrorFromNameLookup.set('InvalidTransferAuthority', () => new InvalidTransferAuthorityError());
/**
 * InstructionNotSupported: 'Instruction not supported for ProgrammableNonFungible assets'
 *
 * @category Errors
 * @category generated
 */
class InstructionNotSupportedError extends Error {
    constructor() {
        super('Instruction not supported for ProgrammableNonFungible assets');
        this.code = 0x99;
        this.name = 'InstructionNotSupported';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InstructionNotSupportedError);
        }
    }
}
exports.InstructionNotSupportedError = InstructionNotSupportedError;
createErrorFromCodeLookup.set(0x99, () => new InstructionNotSupportedError());
createErrorFromNameLookup.set('InstructionNotSupported', () => new InstructionNotSupportedError());
/**
 * KeyMismatch: 'Public key does not match expected value'
 *
 * @category Errors
 * @category generated
 */
class KeyMismatchError extends Error {
    constructor() {
        super('Public key does not match expected value');
        this.code = 0x9a;
        this.name = 'KeyMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, KeyMismatchError);
        }
    }
}
exports.KeyMismatchError = KeyMismatchError;
createErrorFromCodeLookup.set(0x9a, () => new KeyMismatchError());
createErrorFromNameLookup.set('KeyMismatch', () => new KeyMismatchError());
/**
 * LockedToken: 'Token is locked'
 *
 * @category Errors
 * @category generated
 */
class LockedTokenError extends Error {
    constructor() {
        super('Token is locked');
        this.code = 0x9b;
        this.name = 'LockedToken';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, LockedTokenError);
        }
    }
}
exports.LockedTokenError = LockedTokenError;
createErrorFromCodeLookup.set(0x9b, () => new LockedTokenError());
createErrorFromNameLookup.set('LockedToken', () => new LockedTokenError());
/**
 * UnlockedToken: 'Token is unlocked'
 *
 * @category Errors
 * @category generated
 */
class UnlockedTokenError extends Error {
    constructor() {
        super('Token is unlocked');
        this.code = 0x9c;
        this.name = 'UnlockedToken';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UnlockedTokenError);
        }
    }
}
exports.UnlockedTokenError = UnlockedTokenError;
createErrorFromCodeLookup.set(0x9c, () => new UnlockedTokenError());
createErrorFromNameLookup.set('UnlockedToken', () => new UnlockedTokenError());
/**
 * MissingDelegateRole: 'Missing delegate role'
 *
 * @category Errors
 * @category generated
 */
class MissingDelegateRoleError extends Error {
    constructor() {
        super('Missing delegate role');
        this.code = 0x9d;
        this.name = 'MissingDelegateRole';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingDelegateRoleError);
        }
    }
}
exports.MissingDelegateRoleError = MissingDelegateRoleError;
createErrorFromCodeLookup.set(0x9d, () => new MissingDelegateRoleError());
createErrorFromNameLookup.set('MissingDelegateRole', () => new MissingDelegateRoleError());
/**
 * InvalidAuthorityType: 'Invalid authority type'
 *
 * @category Errors
 * @category generated
 */
class InvalidAuthorityTypeError extends Error {
    constructor() {
        super('Invalid authority type');
        this.code = 0x9e;
        this.name = 'InvalidAuthorityType';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidAuthorityTypeError);
        }
    }
}
exports.InvalidAuthorityTypeError = InvalidAuthorityTypeError;
createErrorFromCodeLookup.set(0x9e, () => new InvalidAuthorityTypeError());
createErrorFromNameLookup.set('InvalidAuthorityType', () => new InvalidAuthorityTypeError());
/**
 * MissingTokenRecord: 'Missing token record account'
 *
 * @category Errors
 * @category generated
 */
class MissingTokenRecordError extends Error {
    constructor() {
        super('Missing token record account');
        this.code = 0x9f;
        this.name = 'MissingTokenRecord';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingTokenRecordError);
        }
    }
}
exports.MissingTokenRecordError = MissingTokenRecordError;
createErrorFromCodeLookup.set(0x9f, () => new MissingTokenRecordError());
createErrorFromNameLookup.set('MissingTokenRecord', () => new MissingTokenRecordError());
/**
 * MintSupplyMustBeZero: 'Mint supply must be zero for programmable assets'
 *
 * @category Errors
 * @category generated
 */
class MintSupplyMustBeZeroError extends Error {
    constructor() {
        super('Mint supply must be zero for programmable assets');
        this.code = 0xa0;
        this.name = 'MintSupplyMustBeZero';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MintSupplyMustBeZeroError);
        }
    }
}
exports.MintSupplyMustBeZeroError = MintSupplyMustBeZeroError;
createErrorFromCodeLookup.set(0xa0, () => new MintSupplyMustBeZeroError());
createErrorFromNameLookup.set('MintSupplyMustBeZero', () => new MintSupplyMustBeZeroError());
/**
 * DataIsEmptyOrZeroed: 'Data is empty or zeroed'
 *
 * @category Errors
 * @category generated
 */
class DataIsEmptyOrZeroedError extends Error {
    constructor() {
        super('Data is empty or zeroed');
        this.code = 0xa1;
        this.name = 'DataIsEmptyOrZeroed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DataIsEmptyOrZeroedError);
        }
    }
}
exports.DataIsEmptyOrZeroedError = DataIsEmptyOrZeroedError;
createErrorFromCodeLookup.set(0xa1, () => new DataIsEmptyOrZeroedError());
createErrorFromNameLookup.set('DataIsEmptyOrZeroed', () => new DataIsEmptyOrZeroedError());
/**
 * MissingTokenOwnerAccount: 'Missing token owner'
 *
 * @category Errors
 * @category generated
 */
class MissingTokenOwnerAccountError extends Error {
    constructor() {
        super('Missing token owner');
        this.code = 0xa2;
        this.name = 'MissingTokenOwnerAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingTokenOwnerAccountError);
        }
    }
}
exports.MissingTokenOwnerAccountError = MissingTokenOwnerAccountError;
createErrorFromCodeLookup.set(0xa2, () => new MissingTokenOwnerAccountError());
createErrorFromNameLookup.set('MissingTokenOwnerAccount', () => new MissingTokenOwnerAccountError());
/**
 * InvalidMasterEditionAccountLength: 'Master edition account has an invalid length'
 *
 * @category Errors
 * @category generated
 */
class InvalidMasterEditionAccountLengthError extends Error {
    constructor() {
        super('Master edition account has an invalid length');
        this.code = 0xa3;
        this.name = 'InvalidMasterEditionAccountLength';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidMasterEditionAccountLengthError);
        }
    }
}
exports.InvalidMasterEditionAccountLengthError = InvalidMasterEditionAccountLengthError;
createErrorFromCodeLookup.set(0xa3, () => new InvalidMasterEditionAccountLengthError());
createErrorFromNameLookup.set('InvalidMasterEditionAccountLength', () => new InvalidMasterEditionAccountLengthError());
/**
 * IncorrectTokenState: 'Incorrect token state'
 *
 * @category Errors
 * @category generated
 */
class IncorrectTokenStateError extends Error {
    constructor() {
        super('Incorrect token state');
        this.code = 0xa4;
        this.name = 'IncorrectTokenState';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, IncorrectTokenStateError);
        }
    }
}
exports.IncorrectTokenStateError = IncorrectTokenStateError;
createErrorFromCodeLookup.set(0xa4, () => new IncorrectTokenStateError());
createErrorFromNameLookup.set('IncorrectTokenState', () => new IncorrectTokenStateError());
/**
 * InvalidDelegateRole: 'Invalid delegate role'
 *
 * @category Errors
 * @category generated
 */
class InvalidDelegateRoleError extends Error {
    constructor() {
        super('Invalid delegate role');
        this.code = 0xa5;
        this.name = 'InvalidDelegateRole';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidDelegateRoleError);
        }
    }
}
exports.InvalidDelegateRoleError = InvalidDelegateRoleError;
createErrorFromCodeLookup.set(0xa5, () => new InvalidDelegateRoleError());
createErrorFromNameLookup.set('InvalidDelegateRole', () => new InvalidDelegateRoleError());
/**
 * MissingPrintSupply: 'Print supply is required for non-fungibles'
 *
 * @category Errors
 * @category generated
 */
class MissingPrintSupplyError extends Error {
    constructor() {
        super('Print supply is required for non-fungibles');
        this.code = 0xa6;
        this.name = 'MissingPrintSupply';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingPrintSupplyError);
        }
    }
}
exports.MissingPrintSupplyError = MissingPrintSupplyError;
createErrorFromCodeLookup.set(0xa6, () => new MissingPrintSupplyError());
createErrorFromNameLookup.set('MissingPrintSupply', () => new MissingPrintSupplyError());
/**
 * MissingMasterEditionAccount: 'Missing master edition account'
 *
 * @category Errors
 * @category generated
 */
class MissingMasterEditionAccountError extends Error {
    constructor() {
        super('Missing master edition account');
        this.code = 0xa7;
        this.name = 'MissingMasterEditionAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingMasterEditionAccountError);
        }
    }
}
exports.MissingMasterEditionAccountError = MissingMasterEditionAccountError;
createErrorFromCodeLookup.set(0xa7, () => new MissingMasterEditionAccountError());
createErrorFromNameLookup.set('MissingMasterEditionAccount', () => new MissingMasterEditionAccountError());
/**
 * AmountMustBeGreaterThanZero: 'Amount must be greater than zero'
 *
 * @category Errors
 * @category generated
 */
class AmountMustBeGreaterThanZeroError extends Error {
    constructor() {
        super('Amount must be greater than zero');
        this.code = 0xa8;
        this.name = 'AmountMustBeGreaterThanZero';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AmountMustBeGreaterThanZeroError);
        }
    }
}
exports.AmountMustBeGreaterThanZeroError = AmountMustBeGreaterThanZeroError;
createErrorFromCodeLookup.set(0xa8, () => new AmountMustBeGreaterThanZeroError());
createErrorFromNameLookup.set('AmountMustBeGreaterThanZero', () => new AmountMustBeGreaterThanZeroError());
/**
 * InvalidDelegateArgs: 'Invalid delegate args'
 *
 * @category Errors
 * @category generated
 */
class InvalidDelegateArgsError extends Error {
    constructor() {
        super('Invalid delegate args');
        this.code = 0xa9;
        this.name = 'InvalidDelegateArgs';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidDelegateArgsError);
        }
    }
}
exports.InvalidDelegateArgsError = InvalidDelegateArgsError;
createErrorFromCodeLookup.set(0xa9, () => new InvalidDelegateArgsError());
createErrorFromNameLookup.set('InvalidDelegateArgs', () => new InvalidDelegateArgsError());
/**
 * MissingLockedTransferAddress: 'Missing address for locked transfer'
 *
 * @category Errors
 * @category generated
 */
class MissingLockedTransferAddressError extends Error {
    constructor() {
        super('Missing address for locked transfer');
        this.code = 0xaa;
        this.name = 'MissingLockedTransferAddress';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingLockedTransferAddressError);
        }
    }
}
exports.MissingLockedTransferAddressError = MissingLockedTransferAddressError;
createErrorFromCodeLookup.set(0xaa, () => new MissingLockedTransferAddressError());
createErrorFromNameLookup.set('MissingLockedTransferAddress', () => new MissingLockedTransferAddressError());
/**
 * InvalidLockedTransferAddress: 'Invalid destination address for locked transfer'
 *
 * @category Errors
 * @category generated
 */
class InvalidLockedTransferAddressError extends Error {
    constructor() {
        super('Invalid destination address for locked transfer');
        this.code = 0xab;
        this.name = 'InvalidLockedTransferAddress';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidLockedTransferAddressError);
        }
    }
}
exports.InvalidLockedTransferAddressError = InvalidLockedTransferAddressError;
createErrorFromCodeLookup.set(0xab, () => new InvalidLockedTransferAddressError());
createErrorFromNameLookup.set('InvalidLockedTransferAddress', () => new InvalidLockedTransferAddressError());
/**
 * DataIncrementLimitExceeded: 'Exceeded account realloc increase limit'
 *
 * @category Errors
 * @category generated
 */
class DataIncrementLimitExceededError extends Error {
    constructor() {
        super('Exceeded account realloc increase limit');
        this.code = 0xac;
        this.name = 'DataIncrementLimitExceeded';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DataIncrementLimitExceededError);
        }
    }
}
exports.DataIncrementLimitExceededError = DataIncrementLimitExceededError;
createErrorFromCodeLookup.set(0xac, () => new DataIncrementLimitExceededError());
createErrorFromNameLookup.set('DataIncrementLimitExceeded', () => new DataIncrementLimitExceededError());
/**
 * CannotUpdateAssetWithDelegate: 'Cannot update the rule set of a programmable asset that has a delegate'
 *
 * @category Errors
 * @category generated
 */
class CannotUpdateAssetWithDelegateError extends Error {
    constructor() {
        super('Cannot update the rule set of a programmable asset that has a delegate');
        this.code = 0xad;
        this.name = 'CannotUpdateAssetWithDelegate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotUpdateAssetWithDelegateError);
        }
    }
}
exports.CannotUpdateAssetWithDelegateError = CannotUpdateAssetWithDelegateError;
createErrorFromCodeLookup.set(0xad, () => new CannotUpdateAssetWithDelegateError());
createErrorFromNameLookup.set('CannotUpdateAssetWithDelegate', () => new CannotUpdateAssetWithDelegateError());
/**
 * InvalidAmount: 'Invalid token amount for this operation or token standard'
 *
 * @category Errors
 * @category generated
 */
class InvalidAmountError extends Error {
    constructor() {
        super('Invalid token amount for this operation or token standard');
        this.code = 0xae;
        this.name = 'InvalidAmount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidAmountError);
        }
    }
}
exports.InvalidAmountError = InvalidAmountError;
createErrorFromCodeLookup.set(0xae, () => new InvalidAmountError());
createErrorFromNameLookup.set('InvalidAmount', () => new InvalidAmountError());
/**
 * MissingMasterEditionMintAccount: 'Missing master edition mint account'
 *
 * @category Errors
 * @category generated
 */
class MissingMasterEditionMintAccountError extends Error {
    constructor() {
        super('Missing master edition mint account');
        this.code = 0xaf;
        this.name = 'MissingMasterEditionMintAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingMasterEditionMintAccountError);
        }
    }
}
exports.MissingMasterEditionMintAccountError = MissingMasterEditionMintAccountError;
createErrorFromCodeLookup.set(0xaf, () => new MissingMasterEditionMintAccountError());
createErrorFromNameLookup.set('MissingMasterEditionMintAccount', () => new MissingMasterEditionMintAccountError());
/**
 * MissingMasterEditionTokenAccount: 'Missing master edition token account'
 *
 * @category Errors
 * @category generated
 */
class MissingMasterEditionTokenAccountError extends Error {
    constructor() {
        super('Missing master edition token account');
        this.code = 0xb0;
        this.name = 'MissingMasterEditionTokenAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingMasterEditionTokenAccountError);
        }
    }
}
exports.MissingMasterEditionTokenAccountError = MissingMasterEditionTokenAccountError;
createErrorFromCodeLookup.set(0xb0, () => new MissingMasterEditionTokenAccountError());
createErrorFromNameLookup.set('MissingMasterEditionTokenAccount', () => new MissingMasterEditionTokenAccountError());
/**
 * MissingEditionMarkerAccount: 'Missing edition marker account'
 *
 * @category Errors
 * @category generated
 */
class MissingEditionMarkerAccountError extends Error {
    constructor() {
        super('Missing edition marker account');
        this.code = 0xb1;
        this.name = 'MissingEditionMarkerAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingEditionMarkerAccountError);
        }
    }
}
exports.MissingEditionMarkerAccountError = MissingEditionMarkerAccountError;
createErrorFromCodeLookup.set(0xb1, () => new MissingEditionMarkerAccountError());
createErrorFromNameLookup.set('MissingEditionMarkerAccount', () => new MissingEditionMarkerAccountError());
/**
 * CannotBurnWithDelegate: 'Cannot burn while persistent delegate is set'
 *
 * @category Errors
 * @category generated
 */
class CannotBurnWithDelegateError extends Error {
    constructor() {
        super('Cannot burn while persistent delegate is set');
        this.code = 0xb2;
        this.name = 'CannotBurnWithDelegate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotBurnWithDelegateError);
        }
    }
}
exports.CannotBurnWithDelegateError = CannotBurnWithDelegateError;
createErrorFromCodeLookup.set(0xb2, () => new CannotBurnWithDelegateError());
createErrorFromNameLookup.set('CannotBurnWithDelegate', () => new CannotBurnWithDelegateError());
/**
 * MissingEdition: 'Missing edition account'
 *
 * @category Errors
 * @category generated
 */
class MissingEditionError extends Error {
    constructor() {
        super('Missing edition account');
        this.code = 0xb3;
        this.name = 'MissingEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingEditionError);
        }
    }
}
exports.MissingEditionError = MissingEditionError;
createErrorFromCodeLookup.set(0xb3, () => new MissingEditionError());
createErrorFromNameLookup.set('MissingEdition', () => new MissingEditionError());
/**
 * InvalidAssociatedTokenAccountProgram: 'Invalid Associated Token Account Program'
 *
 * @category Errors
 * @category generated
 */
class InvalidAssociatedTokenAccountProgramError extends Error {
    constructor() {
        super('Invalid Associated Token Account Program');
        this.code = 0xb4;
        this.name = 'InvalidAssociatedTokenAccountProgram';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidAssociatedTokenAccountProgramError);
        }
    }
}
exports.InvalidAssociatedTokenAccountProgramError = InvalidAssociatedTokenAccountProgramError;
createErrorFromCodeLookup.set(0xb4, () => new InvalidAssociatedTokenAccountProgramError());
createErrorFromNameLookup.set('InvalidAssociatedTokenAccountProgram', () => new InvalidAssociatedTokenAccountProgramError());
/**
 * InvalidInstructionsSysvar: 'Invalid InstructionsSysvar'
 *
 * @category Errors
 * @category generated
 */
class InvalidInstructionsSysvarError extends Error {
    constructor() {
        super('Invalid InstructionsSysvar');
        this.code = 0xb5;
        this.name = 'InvalidInstructionsSysvar';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidInstructionsSysvarError);
        }
    }
}
exports.InvalidInstructionsSysvarError = InvalidInstructionsSysvarError;
createErrorFromCodeLookup.set(0xb5, () => new InvalidInstructionsSysvarError());
createErrorFromNameLookup.set('InvalidInstructionsSysvar', () => new InvalidInstructionsSysvarError());
/**
 * InvalidParentAccounts: 'Invalid or Unneeded parent accounts'
 *
 * @category Errors
 * @category generated
 */
class InvalidParentAccountsError extends Error {
    constructor() {
        super('Invalid or Unneeded parent accounts');
        this.code = 0xb6;
        this.name = 'InvalidParentAccounts';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidParentAccountsError);
        }
    }
}
exports.InvalidParentAccountsError = InvalidParentAccountsError;
createErrorFromCodeLookup.set(0xb6, () => new InvalidParentAccountsError());
createErrorFromNameLookup.set('InvalidParentAccounts', () => new InvalidParentAccountsError());
/**
 * InvalidUpdateArgs: 'Authority cannot apply all update args'
 *
 * @category Errors
 * @category generated
 */
class InvalidUpdateArgsError extends Error {
    constructor() {
        super('Authority cannot apply all update args');
        this.code = 0xb7;
        this.name = 'InvalidUpdateArgs';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidUpdateArgsError);
        }
    }
}
exports.InvalidUpdateArgsError = InvalidUpdateArgsError;
createErrorFromCodeLookup.set(0xb7, () => new InvalidUpdateArgsError());
createErrorFromNameLookup.set('InvalidUpdateArgs', () => new InvalidUpdateArgsError());
/**
 * InsufficientTokenBalance: 'Token account does not have enough tokens'
 *
 * @category Errors
 * @category generated
 */
class InsufficientTokenBalanceError extends Error {
    constructor() {
        super('Token account does not have enough tokens');
        this.code = 0xb8;
        this.name = 'InsufficientTokenBalance';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InsufficientTokenBalanceError);
        }
    }
}
exports.InsufficientTokenBalanceError = InsufficientTokenBalanceError;
createErrorFromCodeLookup.set(0xb8, () => new InsufficientTokenBalanceError());
createErrorFromNameLookup.set('InsufficientTokenBalance', () => new InsufficientTokenBalanceError());
/**
 * MissingCollectionMint: 'Missing collection mint account'
 *
 * @category Errors
 * @category generated
 */
class MissingCollectionMintError extends Error {
    constructor() {
        super('Missing collection mint account');
        this.code = 0xb9;
        this.name = 'MissingCollectionMint';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingCollectionMintError);
        }
    }
}
exports.MissingCollectionMintError = MissingCollectionMintError;
createErrorFromCodeLookup.set(0xb9, () => new MissingCollectionMintError());
createErrorFromNameLookup.set('MissingCollectionMint', () => new MissingCollectionMintError());
/**
 * MissingCollectionMasterEdition: 'Missing collection master edition account'
 *
 * @category Errors
 * @category generated
 */
class MissingCollectionMasterEditionError extends Error {
    constructor() {
        super('Missing collection master edition account');
        this.code = 0xba;
        this.name = 'MissingCollectionMasterEdition';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingCollectionMasterEditionError);
        }
    }
}
exports.MissingCollectionMasterEditionError = MissingCollectionMasterEditionError;
createErrorFromCodeLookup.set(0xba, () => new MissingCollectionMasterEditionError());
createErrorFromNameLookup.set('MissingCollectionMasterEdition', () => new MissingCollectionMasterEditionError());
/**
 * InvalidTokenRecord: 'Invalid token record account'
 *
 * @category Errors
 * @category generated
 */
class InvalidTokenRecordError extends Error {
    constructor() {
        super('Invalid token record account');
        this.code = 0xbb;
        this.name = 'InvalidTokenRecord';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidTokenRecordError);
        }
    }
}
exports.InvalidTokenRecordError = InvalidTokenRecordError;
createErrorFromCodeLookup.set(0xbb, () => new InvalidTokenRecordError());
createErrorFromNameLookup.set('InvalidTokenRecord', () => new InvalidTokenRecordError());
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
function errorFromCode(code) {
    const createError = createErrorFromCodeLookup.get(code);
    return createError != null ? createError() : null;
}
exports.errorFromCode = errorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
function errorFromName(name) {
    const createError = createErrorFromNameLookup.get(name);
    return createError != null ? createError() : null;
}
exports.errorFromName = errorFromName;
